# Chapter 6. Partitioning

## 서론

데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션을 쪼갤 필요가 있다.

이 작업을 **샤딩**이라고도 한다.

데이터 파티셔닝을 원하는 주된 이유는 **확장성**이다.

## 파티셔닝과 복제

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.

각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있다.

## key-value 데이터 파티셔닝

***파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.***

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 ***쏠렸다(skewed)**고 말한다.

불균형하게 부하가 높은 파티션을 **핫스팟**이라고 한다.

레코드를 어떻게 할당하는 것이 좋을까?

- 랜덤 파티셔닝 : 데이터는 고르게 분배되지만, 모든 노드에 병렬 질의를 해야한다.
- 키 범위 기준 파티셔닝 : 범위 스캔이 유용하지만, 타임스탬프가 키라면 핫스팟을 유발할 수 있다.
- 키 해시값 기준 파티셔닝 : 쏠림, 핫스팟을 방지할 수 있지만, 범위 질의를 효율적으로 실행할 수 없다.

***관련 내용***

키 범위 기준 예시로, 센서 데이터베이스 이야기가 나왔다.

센서 데이터베이스에서 이문제를 회피하려면 키의 첫 번째 요소로 타임스탬프가 아닌 다른 것을 사용해야 한다.

실제로 IoT 분야에서 비슷한 방법으로 데이터를 운용하곤 한다.

## 파티셔닝과 보조 색인

보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 검색하는 수단이다.

사용자 123이 실행한 액션을 모두 찾거나 hogwash라는 단어를 포함하는 글을 모두 찾거나 빨간색 자동차를 모두 찾는 등의 작업에 쓰인다.

- 문서 기준 : Document ID 기준으로 파티셔닝하고, scatter/gather 형식으로 질의. 쓰기가 효율적.
- 용어 기준 : 모든 파티션의 데이터를 담당하는 전역 색인이 파티셔닝되어 있음. 읽기가 효율적, 원하는 용어 포함 파티션으로만 요청을 보내면 됨.

## 파티션 재균형화

시간이 지나면 DB에 변화가 생긴다.

- CPU 추가 원한다!
- Disk, Ram 추가 원한다!
- 장비에 장애가 발생해서 다른 장비가 그 역할을 받아야 한다!

클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 ***rebalancing***이라고 한다.

## 재균형화 전략

- 해시값에 모드 N 연산을 실행(**쓰면 안된다!**) : 대부분의 키가 노드를 옮겨야 할 수 있다. 비용이 지나치게 크다.
- 파티션 개수 고정 : 처음부터 파티션을 더 많이 만든다. 새 노드가 추가되면 파티션이 분배될 떄까지 기존 노드에서 파티션을 뻇어온다. 파티션은 노드 사이에서 통째로 이동하기만 하면 된다. 단, 변동이 심해 수를 정하기 어려운 환경이라면 해당 방법을 채택하기 어렵다.
- 동적 파티셔닝 : 파티션 크기가 설정 값을 넘으면 파티션을 두개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다. 반대로 합쳐질 수도 있다. 빈 데이터베이스는 파티션 경계를 어디로 정해야 하는지 사전 정보가 없으므로, 시작할 때는 파티션이 하나라는 함정이 있다. 따라서 pre-splitting을 지원하기도 한다.
- 노드 비례 파티셔닝 : 노드당 할당하는 파티션 개수를 고정한다. 새 노드가 추가되면 고정 개수의 파티션을 무작위 선택해 분할하고 각 분할된 파티션의 절반은 그대로 두고 절반은 새 노드에 할당한다.

### 운영 : 자동 재균형화와 수동 재균형화

재균형화는 자동으로 실행될까, 수동으로 실행될까?

적절히 조합해보는 방법도 있다.

## 요청 라우팅

클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?

***"foo 키를 읽거나 쓰려면 어떤 IP 주소와 포트 번호로 접속해야 할까?"***

이 문제는 DB에 국한되지 않은 **Service Discovery**의 일종이다. 

- 클라이언트가 Round-Robin LB를 통해 접속하게 한다.
- 모든 요청을 라우팅 계층으로 먼저 보내고, 라우팅 계층에서는 노드를 알아내 요청을 전달한다.
- 클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게 한다.

Gosship Protocol : https://medium.com/@heonjang.lee96/gossip-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%9E%80-906500c3de4b

## 병렬 질의 실행

대규모 병렬 처리(massively parallel processing, MPP)는 훨씬 복잡한 질의를 지원한다.

MPP Query Optimizer는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.


# Chapter 7. Transaction

***트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다. (중략) 트랜잭션은 자연 법칙이 아니다. 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것이다.***

### ACID의 의미

ACID 표준을 따르지 않는 시스템을 BASE(Basically Available, Soft state, Eventual consistency)라고 부른다.

### 원자성(Atomicity)

원자성은 동시성과 관련이 없다.

원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경은 효과가 있고 어떤 것은 그렇지 않은지 알기 어렵다.

**abortability**이 원자성보다 나은 단어같다고 한다.

### 일관성(Consistency)

데이터에 관한 어떤 선언(불변식(invariant))이 있다는 것이다.

예를 들어 회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야 한다.

트랜잭션이 이런 불변식이 유효한 데이터베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보전한다면 불변식이 항상 만족한다고 확신할 수 있다.

### 격리성(Isolation)

대부분 동시에 여러 클라이언트에서 데이터베이스에 접속한다.

같은 데이터에 접근한다면?

격리성은 동시에 실행되는 서로 격리된다는 것을 의미하고, 트랜잭션은 다른 트랜잭션을 방해할 수 없다.

데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐떠라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐ㅇ르 때의 결과와 동일하도록 보장한다.

### 지속성(Durability)

지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.

## 단일 객체 연산과 다중 객체 연산

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션 내에 속하는지 알아낼 수단이 있어야 한다.

비관계형 데이터베이스는 이런 식으로 연산을 묶는 방법이 없는 경우가 많다.

따라서 어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 데이터베이스가 부분적으로 갱신된 상태가 될 수 있다.

### 단일 객체 쓰기

여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)을 방지하므로 유용하다. 

### 다중 객체 트랜잭션의 필요성

많은 분산 데이터 스토어는 다중 객체 트랜잭션을 포기했지만, 근본적으로 트랜잭션을 막는 것은 아무것도 없다.

단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있지만, 여러 개의 다른 객체에 실행되는 쓰기 작업이 코디네이션되어야 하는 상황도 있다.

### 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.

하지만 모든 시스템이 그렇진 않기 때문에 오류 복구가 애플리케이션에게 책임이 있는 경우가 있다.

어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.