# 06. 파티셔닝

목적: 확장성 (다른 노드에 저장, 대용량 데이터셋이 여러 디스크에 분산, 질의 부하도 여러 프로세서에 분산)

크고 복잡한 질의는 더 어렵지만, 여러 노드에서 병렬 쿼리 질의 실행 가능

- 이번 장 에서는...
    - 대용량 데이터셋을 파티셔닝 하는 방법
    - 테이터 색인과 파티셔닝의 상호작용
    - 재균형화
    - 데이터베이스가 어떻게 요청을 올바른 파티션에 전달하고 질의를 실행하는지

## 파티셔닝과 복제

각 파티션의 복제본을 여러 노드에 저장

각 레코드는 한 파티션에 속해도, 여러 노드에 저장해 내결함성을 보장

그림 6-1 (201p): 한 노드에 여러 파티션을 저장 (각 노드는 어떤 파티션에게는 리더, 어떤 파티션에게는 팔로워)

## 키-값 데이터 파티셔닝

어떤 레코드를 어떤 노드에 저장할 것인가?

데이터나 질의한 특정 노드에 쏠린다면(skewed, 핫스팟) 파티셔닝 효과가 떨어짐

- 방법 1: 무작위
    - 장점: 매우 고르게 분산
    - 단점: 값을 읽을 때 어느 파티션에 저장되었는지 알 수 없어, 모든 노드에서 병렬적으로 질의 실행 필요
- 방법 2: 키 범위 기준
    - 각 파티션에 연속된 범위의 키를 할당 (like 백과사전)
    - 장점: 범위 경계를 알면 어떤 키가 어느 파티션에 저장됐는지 알 수 있음, 범위 질의 효율적
    - 단점: 핫스팟 유발 (센서 데이터를 타임 스탬프를 키로 파티셔닝 하는 예시, 203p)
- 방법 3: 키 해시값 기준
    - 좋은 해시 함수를 통해 쏠린 데이터를 균일하게 분산
    - Object.hashCode()는 같은 키를 넣어도 프로세스에 따라 다른 해시값을 반환
    - 장점: 균일하게 데이터를 분산해 핫스팟 완화
    - 단점: 범위 질의를 효율적으로 실행할 수 없음 (인접 키 정렬 순서 유지 X, 모든 파티션에 질의 필요)
- 방법 4: 애플리케이션에서 작업 부하 보정
    - 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠릴 수 있음 (ex. SNS의 유명인)
    - 데이터 시스템이 핫스팟을 자동으로 보정하지 못하므로, 애플리케이션에서 작업 부하 보정
    - 예시: 키의 시작이나 끝에 임의의 숫자를 붙이기
        - 장점: 한 키에 대한 쓰기 작업이 균등하게 분산
        - 단점: 한 키에 대한 읽기 작업 시 분산된 파티션으로 부터 데이터를 읽어 조합 필요

## 파티셔닝과 보조 색인

키-값 파티셔닝 방식: 기본키를 통해서 파티션을 결정, 담당 파티션으로 읽기, 쓰기 요청

보조 색인: 레코드를 유일하게 식별하는 용도(ex. 기본키)가 아니라 특정 값이 발생한 항목을 검색하는 수단 ⇒ 파티셔닝에 대응되지 않는 문제점

- 문서 기준 보조 색인 파티셔닝
    - 각 파티션은 자신의 보조 색인을 유지, 파티션에 속하는 문서만 담당 (독립적, 지역 색인)
    - 단점: 읽기 시 모든 파티션으로 병렬 질의 (scatter/gather 방식, 꼬리 지연 시간 증폭)
    - 몽고 DB, Elastic Search
- 용어 기준 보조 색인 파티셔닝
    - 모든 파티션의 데이터를 담당하는 전역 색인 (한 노드에만 색인을 저장하는 것은 아님)
    - 장점:  읽기 효율 (scatter/gather X)
    - 단점: 쓰기가 느리고 복잡 (단일 문서를 쓸 때 여러 파티션에 영향)
    - 비동기 갱신 (쓰기 실행 후 바로 색인을 읽으면 변경 사항이 반영되지 않을 수 있다, [분산 트랜잭션](https://ko.wikipedia.org/wiki/%EB%B6%84%EC%82%B0_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)을 지원하지 않는 DB)

## 파티션 재균형화

재균형화: 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정

- 기대 요구 사항
    - 부하(데이터 저장소, 질의 요쳥)이 노드 사이 균등하게 분배
    - 재균형화 도중에도 질의 요청 처리
    - 노드 사이 데이터 이동 최소화
- 재균형화 전략
    - 쓰면 안되는 방법: 해시값에 모드 N 연산 실행
        - 노드 개수가 바뀌면 대부분의 키가 노드 사이 이동
    - 파티션 개수 고정
        - 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당
        - 노드가 추가되면 균등하게 분배될 때 까지 기존 노드에서 새 노드로 파티션을 뺏어오기
        - 파티션 개수, 파티션에 할당된 키 변경 X, 노드에 어떤 파티션이 할당되는가만 변화
        - 네트워크 데이터 전송 시간 필요 ⇒ 재균형화 도중 질의는 기존 할당 파티션에서 처리
        - 적절한 파티션 사이즈?
            - 너무 크다면: 재균형화, 노드 복구 비용이 크다
            - 너무 작다면: 개수가 많으므로 관리 오버헤드가 크다
        - Elastic Search
    - 동적 파티셔닝
        - 파티션 크기가 설정된 값을 넘어서면, 파티션을 동적으로 쪼갬
        - 데이터가 삭제되어 파티션 크기가 설정된 값보다 작아지면, 파티션을 동적으로 병합
        - 파티션 개수가 전체 데이터 용량에 맞춰 조정
        - 사전 분할: 빈 데이터 베이스에 초기 파티션 집합을 설정 (하나의 파티션, 노드로 모든 요청이 쏠리는 것을 막기 위해)
        - HBase
    - 노드 비례 파티셔닝
        - 노드 개수에 비례하게 파티션 개수 조정 (노드당 할당 파티션 개수 고정)
        - 노드 추가 시, 기존 파티션을 분할하고 새 노드로
- 자동 vs 수동 재균형화
    - 자동 재균형화: 유지보수가 쉽지만 예측이 어려움 (노드, 네트워크 과부화 / 다른 요청 성능 저하)
    - 수동 재균형화: 느리지만 운영상 예상치 못한 일 방지

## 요청 라우팅

- 재균형 시 노드에 할당된 파티션이 바뀌는데, 어떤 노드로 클라이언트가 접속해야 할까? (그림 6-7)
    - 클라이언트는 아무 노드에 접속, 올바른 노드로 요청을 전달
    - 클라이언트는 모든 요청을 라우팅 계층에. 라우팅 계층은 파티션 인지 로드 밸런서 역할
    - 클라이언트가 직접 파티션 위치를 알고 있음
- 주키퍼 (ZooKeeper, 코디네이션 서비스)
    - 각 노드는 주키퍼에 자신을 등록
    - 주키퍼는 파티션, 노드 사이 할당 정보를 관리
    - 파티션 소유 노드가 바뀌면 주키퍼는 라우팅 계층에 전파해 최신 정보 유지

# 07. 트랜잭션

트랜잭션: 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법

전체가 성공하면 커밋, 실패하면 롤백 (부분적인 실패 걱정 X)

## 애매모호한 트랜잭션의 개념

- ACID의 의미
    - 원자성 (Atomicity): 개별 작업이 완료(커밋)될 수 없다면 어보트(롤백)
    - 일관성 (Consistency): 불변식(제약조건)이 맞음 (애플리케이션의 속성, DB가 보장할 수 없음)
    - 격리성 (Isolation): 동시에 실행된 트랜잭션은 서로 격리 (독립적으로)
        - Read Uncommited
        - Read Commited
        - Repeatable Read
        - Serializable
    - 지속성 (Duration): 성공한 트랜잭션은 영구적으로 손실되지 않음
- 단일 객체 연산과 다중 객체 연산
    - 이메일 예시 (dirty read, 그림 7-2)
    - 같은 트랜잭션의 기준: 특정 연결 내 BEGIN TRANSACTION과 COMMIT 사이
    - 단일 객체 쓰기
        - 원자성: 장애 복구용 로그(?), 더 복잡한 원자적 연산
        - 격리성: 각 객체에 잠금 (동시에 한 스레드만 접근하도록)
    - 다중 객체 트랜잭션의 필요성
    - 오류와 어보트 처리
        - 오류가 생기면 어보트 되기 때문에 안전하게 재시도 가능 (애플리케이션의 책임)
        - 그러나 재시도가 완벽한 오류 처리 매커니즘은 아님
            - 트랜잭션이 성공했지만, 서버가 클라이언트에게 커밋 성공을 알리는 도중 네트워크가 끊긴다면 중복 트랜잭션 발생도 가능
            - 재시도 횟수, 백오프가 없다면 과부화 문제 악화
            - 외부 부수 효과 가능성 (2단계 커밋 필요)
