# 일괄 처리

- 온라인 시스템에서는 응답 시간 단축에 노력을 많이 기울인다.
- 시스템 유형
	- 서비스(온라인 시스템) : 클라이언트로부터 요청이나 지시가 올 때까지 기다린다. 요청이 들어오면 가능한 빨리 요청을 처리해 응답을 되돌려 보내려 한다. 응답 시간
	- 일괄 처리 시스템(오프라인 시스템) : 매우 큰 입력 데이터를 받아 데이터를 처리한다. 작업이 끝날 때까지 대기하지 않는다. 반복적인 일정으로 수행한다. 처리량
	- 스트림 처리 시스템(준실시간 시스템) : 온라인과 오프라인/일괄 처리 사이의 어딘가에 있다. 요청에 대해 응답하지 않으며 입력 데이터를 소비하고 출력 데이터를 생산한다. 입력 이벤트가 발생한 직후 바로 작동한다.

- 일괄 처리는 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션을 구축하는 데 매우 중요한 구성요소다.

## 유닉스 도구로 일괄 처리하기

### 단순 로그 분석

- 다양한 도구를 사용해 로그를 처리하고 웹사이트 트래픽에 대한 보고서를 깔끔하게 만들 수 있다.

### 정렬 대 인메모리 집계

- 작업 세트 : 작업에서 임의 접근이 필요한 메모리 양
- 작업 세트가 충분히 작다면 인메모리 해시 테이블도 잘 작동한다.
- 허용 메모리보다 작업 세트가 크다면 정렬 접근법을 사용하는 것이 좋다.

### 유닉스 철학

- 유닉스 철학
	- 각 프로그램이 한 가지 일만 하도록 작성하라.
	- 모든 프로그램의 출력은 아직 알려지지 않은 다른 프로그램의 입력으로 쓰일 수 있다고 생각하라.
	- 소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라.
	- 프로그래밍 작업을 줄이려면 미숙한 도움보단 도구를 사용하라.

### 동일 인터페이스

- 특정 프로그램이 다른 어떤 프로그램과도 연결 가능하려면 프로그램 모두가 같은 입출력 인터페이스를 사용해야 한다.
- 유닉스에서의 인터페이스는 파일(파일 디스크립터)이다.
- 동일한 데이터 모델인 데이터베이스 간에도 한쪽에서 다른 쪽으로 데이터를 옮기는 것은 쉽지 않다.

### 로직과 연결의 분리

- 유닉스 도구는 표준 입력과 표준 출력을 사용한다.
- 파이프는 한 프로세스의 stdout을 다른 프로세스의 stdin과 연결한다. 중간 데이터를 디스크에 쓰지 않고 작은 인메모리 버퍼를 사용해 프로세스 간 데이터를 전송한다.
- 느슨한 결합/지연 바인딩/제어 반전 : 쉘 사용자는 유닉스 접근법으로 원하는 대로 입력과 출력을 연결할 수 있다. 프로그램은 입력이 어디서부터 들어오는지 출력이 어디로 나가는지 신경 쓰거나 알 필요조차 없다.
- stdin과 stdout을 사용할 때 제약사항
	- 여러 개의 입력을 받거나 여러 개의 출력이 필요할 때는 불가능하지는 않지만 까다롭다.
	- 프로그램의 출력을 파이프를 이용해 네트워크와 연결하지 못한다.

### 투명성과 실험

- 유닉스 도구가 성공적인 이유
	- 유닉스 명령에 들어가는 입력 파일은 일반적으로 불변으로 처리된다. 다양한 명령을 수행하더라도 입력 파일에는 손상을 주지 않는다.
	- 어느 시점이든 파이프라인을 중단하고 출력을 파이프를 통해 less로 보내 원하는 형태의 출력이 나오는지 확인할 수 있다. 디버깅할 때 매우 유용하다.
	- 특정 파이프라인 단계의 출력을 파일에 쓰고 그 파일을 다음 단계의 입력으로 사용할 수 있다.

- 가장 큰 제약은 단일 장비에서만 실행된다는 점이다.

## 맵리듀스와 분산 파일 시스템

- 맵리듀스는 유닉스 도구와 비슷한 면이 있지만 수천 대의 장비로 분산해서 실행이 가능하다는 점에서 차이가 있다.
- 맵리듀스 작업은 분산 파일 시스템상의 파일을 입력과 출력으로 사용한다. 이 파일 시스템을 HDFS(Haddop Distributed File System)라고 한다.
- HDFS는 각 장비에서 실행되는 데몬 프로세스로 구성된다.
	- 데몬 프로세스는 다른 노드가 해당 장비에 저장된 파일에 접근 가능하게끔 네트워크 서비스를 제공한다.
	- 네임노드라고 부르는 중앙 서버는 특정 파일 블록이 어느 장비에 저장됐는지 추적한다.
- 장비가 죽거나 디스크가 실패하는 경우에 대비하기 위해 파일 블록은 여러 장비에 복제된다.
	- 단순히 여러 장비에 동일한 데이터를 복사하는 방식
	- 리드 솔로몬 코드같은 삭제 코딩 방식을 사용해 적은 저장소 부담으로 손실된 데이터를 복구하는 방식, RAID와 유사하다.
- HDFS는 확장성이 매우 뛰어나다

### 맵리듀스 작업 실행하기

- 맵리듀스는 HDFS 같은 분산 파일 시스템 위에서 대용량 데이터셋을 처리하는 코드를 작성하는 프로그래밍 프레임워크다.
- 맵리듀스의 데이터 처리 패턴
	- 입력 파일을 읽는다. 레코드로 쪼갠다.
	- 각 입력 레코드마다 매퍼 함수를 호출해 키와 값을 추출한다.
	- 키를 기준으로 키-값 쌍을 모두 정렬한다.
	- 정렬된 키-값 쌍 전체를 대상으로 리듀스 함수를 호출한다.

- 두 가지 콜백 함수
	- 매퍼 : 매퍼는 모든 입력 레코드마다 한 번씩만 호출된다. 매퍼는 입력 레코드로부터 키와 값을 추출하는 작업이다.
	- 리듀서 : 매퍼가 생상한 키-값 쌍을 받아 같은 키를 가진 레코드를 모으로 해당 값의 집합을 반복해 리듀서 함수를 호출한다. 출력 레코드를 생산한다.

### 맵리듀스의 분산 실행

- 병렬로 수행하는 코드를 직접 작성하지 않고도 여러 장비에서 동시에 처리가 가능하다.
- 매퍼와 리듀서는 한 번에 하나의 레코드만 처리하고 입력이 어디서 오는지 출력이 어디로 가는지 신경 쓰지 않는다.
- 데이터 가까이에서 연산하기 : 매퍼 입력 파일의 복제본이 있는 장비에 RAM과 CPU에 여유가 충분하다면 맵리듀스 스케줄러가 입력 파일이 있는 장비에서 작업을 수행하려 한다. 네트워크 부하가 감소하고 지역성이 증가한다.
- 맵리듀스 프레임워크는 같은 키를 가진 모든 키-값 쌍을 같은 리듀서에서 처리하는 것을 보장한다. 어느 리듀스 태스크에서 수행될지 결정하기 위해 키의 해쉬값을 사용한다.
- 리듀서를 기준으로 파티셔닝하고 정렬한 뒤 매퍼로부터 데이터 파티션을 복사하는 과정을 셔플이라 한다.

### 맵리듀스 워크플로

- 맵리듀스 작업을 연결해 워크플로로 구성하는 방식은 맵리듀스 작업 하나의 출력을 다른 맵리듀스 작업의 입력으로 이용하는 식이다.
- 워크플로 상에서 해당 작업의 입력 디렉터리를 생성하는 선행 작업이 완전히 끝나야만 다음 작업을 시작할 수 있다.

### 리듀스 사이드 조인과 그룹화

- 한 레코드가 다른 레코드와 연관이 있는 것을 외래키, 문서 참조, 간선 이라고 부른다.
- 전체 테이블 스캔 : 파일 집합이 입력으로 주어진 맵리듀스 작업이 있다면 맵리듀스 작업은 입력 파일 전체 내용을 읽는다.
- 일괄 처리 맥락에서 조인은 데이터셋 내 모든 연관 관계를 다룬다는 뜻이다.

### 정렬 병합 조인

- 보조 정렬 : 리듀서가 항상 사용자 데이터베이스를 먼저 보고 활동 이벤트를 시간 순으로 보게하는 식으로 맵리듀스에서 작업 레코드를 재배열하는 기술
- 정렬 병합 조인 : 매퍼 출력이 키로 정렬된 후에 리듀서가 조인의 양측의 정렬된 레코드 목록을 병합한다

### 그룹화

- 조인 외에도 "같은 곳으로 관련 데이털르 모으는" 일반적인 사용 유형은 "GROUP BY"절과 같이 특정 키로 레코드를 그룹화하는 것이다.
- 그룹화할 대상을 키로 하여 맵리듀스로 그룹화 연산을 구현할 수 있다.
- 세션화 : 특정 사용자가 취한 일련의 활동을 찾기 위해 사용자 세션별 활동 이벤트를 수집 분석하는 것

### 쏠림 다루기

- 불균형한 활성 데이터베이스 레코드를 린치핀 객체, 핫 키라고 한다.
- 핫스팟 : 유명 인사 한 사람에 관련된 모든 활동을 리듀서 한 개에서 모은다면 상당한 쏠림 현상이 생긴다.
- 쏠린 조인 메서드는 어떤 키가 핫 키인지 결정하기 위해 샘플링 작업을 수행한다.
	- 실제 조인을 수행할 때 매퍼는 핫 키를 가진 레코드는 여러 리듀서 중 임의로 선택한 하나로 레코드를 보낸다.

### 맵 사이드 조인

- 리듀스 사이드 조인 : 실제 조인 로직을 리듀서에서 수행
- 입력 데이터에 대한 특정 가정이 필요없다.
- 정렬 후 리듀서로 복사한 뒤 리듀서 입력을 병합하는 모든 과정에 드는 비용이 상당하다.
- 입력 데이터에 대해 특정 가정이 가능하다면 맵사이드 조인으로 불리는 기법을 사용해 조인을 더 빠르게 수행할 수 있다.

### 브로드캐스트 해시 조인

- 매퍼가 시작할 때 분산 파일 시스템에서 작은 데이터셋을 읽어서 인메모리 해시 테이블에 넣는다.
- 각 맵 태스크에 조인할 큰 입력 파일 블록 중 하나를 할당한다. 모든 매퍼는 작은 입력 전체를 메모리에 적재한다.
- 인메모리 해시 테이블로 적재하는 대신 로컬 디스크에 읽기 전용 색인으로 저장하기도 한다.

### 파티션 해시 조인

- 맵 사이드 조인의 입력을 파티셔닝한다면 해시 조인 접근법을 각 파티션에 독립적으로 적용할 수 있다.
- 조인할 레코드 모두가 같은 번호의 파티션에 위치한다.
- 각 매퍼틑 각 입력 데이터셋 중 파티션 한 개만 읽어도 충분하다.


### 맵 사이드 병합 조인

- 입력 데이터셋이 같은 방식으로 파티셔닝됐을 뿐 아니라 같은 키를 기준으로 정렬됐다면 변형된 맵 사이드 조인을 적용할 수 있다.
- 오름차순으로 양쪽 입력 모두를 점진적으로 읽어 키가 동일한 레코드를 맞춘다.

### 맵 사이드 조인을 사용하는 맵리듀스 워크플로

- 리듀스 사이드 조인은 조인 키로 파티셔닝하고 정렬해서 출력한다.
- 맵 사이드 조인은 큰 입력과 동일한 방법으로 파티셔닝하고 정렬한다.

### 검색 색인 구축

- 정해진 문서 집합을 대상으로 전문 검색이 필요하다면 일괄 처리가 색인을 구축하는 데 매우 효율적이다.
- 매퍼는 필요에 따라 문서 집합을 파티셔닝하고 각 리듀서가 해당 파티션에 대한 색인을 구축한다.

### 일괄 처리의 출력으로 키-값을 저장

- 배치 프로세스의 출력을 웹 어플리케이션이 질의하는 데이터베이스로 보내는 방법
	- 데이터베이스 클라이언트 라이브러리르 사용해 일괄 처리 작업이 한번에 레코드 하나씩 데이터베이스 서버로 직접 요청을 보내는 방법
		- 모든 레코드마다 네트워크 요청을 하는 작업은 상당히 느리다.
		- 데이터베이스가 과부하 상태에 빠지기 쉽고 질의 성능도 나빠진다.
		- 작업 내부에서 외부 시스템에 기록한다면 외부에 드러나는 부수 효과를 만들어낸다.
	- 일괄 처리 작업 내부에 완전히 새로운 데이터베이스를 구축해 분산 파일 시스템의 작업 출력 디렉터리에 저장하는 방법

### 일괄 처리 출력에 관한 철학

-  입력을 불변으로 처리하고 외부 데이터베이스에 기록하는 등의 부수 효과를 피하기 때문에 일괄 처리 작업은 좋은 성능을 내면서도 유지보수가 훨씬 간단하다.
	-  코드에 버그가 있어 출력이 잘못되거나 오염됐다면 코드를 이전 버전으로 돌리고 작업을 재수행해 간단하게 출력을 고칠 수 있다.
	-  쉽게 되돌릴 수 있는 속성의 결과로 실수를 하면 손상을 되돌릴 수 없는 환경에서보다 기능 개발을 빠르게 진행할 수 있다.
	-  맵이나 리듀스 태스크가 실패하면 맵리듀스 프레임워크가 해당 태스크를 자동으로 다시 스테줄링하고 동일한 입력을 사용해 재실행한다.
	-  다양한 작업에서 입력으로 동일한 파일 집합을 사용하곤 한다.
	-  입출력 디렉터리를 설정하는 등의 연결 작업과 로직을 분리한다. 관심사를 따로 처리할 수 있고 코드 재사용도 가능하다.

### 저장소의 다양성

- 하둡은 데이터가 어떤 형태라도 상관없이 HDFS로 덤프할 수 있는 가능성을 열어 놓았다.
- 현실에서는 이상적인 데이터 모델을 만들려고 하기보다 데이터를 빨리 사용 가능하게 만드는 것이 더 가치 있다.
- 초밥 원리 : 하나의 이상적인 데이터 모델은 존재하지 않을지 몰라도 데이터에는 여러 목적에 적합한 다양한 관점이 존재한다.
- "원시 데이터가 더 좋다"

### 처리 모델의 다양성

- SQL 질의로 모든 종류의 처리를 표현하지는 못한다.
- 맵리듀스를 이용하면 엔지니어는 자신이 작성한 코드를 대용량 데이터셋 상에서 쉽게 실행할 수 있다.
- 하둡 위에서 다른 다양한 처리 모델이 개발됐다. 
- 다양한 처리 모델은 모두 단일 공유 클러스터 장비에서 실행되고 분산 파일 시스템상에 존재하는 동일한 파일들에 접근 가능하다.

### 빈번하게 발생하는 결함을 줄이는 설계

- MPP 데이터베이스
	- 질의 실행 중에 한 장비만 죽어도 MPP 데이터베이스 대부분은 전체 질의가 중단된다.
	- 디스크에서 데이터를 읽는 비용을 피하기 위해 조인 같은 방식을 사용해 가능하면 메모리에 많은 데이털르 유지하는 것을 선호한다.

- 맵리듀스
	- 맵 또는 리듀스 태스크의 실패를 견딜 수 있다.
	- 데이터를 되도록 디스크에 기록하려 한다.
	- 대용량 작업에 더 적합하다.
 
 - 프로세스를 임의로 종료할 수 있으면 연산 클러스터에서 자원 활용도를 높일 수 있기 때문에 태스크 종료가 될 수 있다.
 - 이런 이유로 맵리듀스는 태스크 종료가 예상치 못하게 자주 발생하더라도 견딜 수 있게 설계됐다.

### 맵리듀스를 넘어

- 맵리듀스는 분산 시스템에서 가능한 여러 프로그래밍 모델 중 단지 하나일 뿐이다.
- 고수준 프로그래밍 모델은 맵리듀스가 어떻게 동작하는지 이해하고 있으면 확실히 배우기 쉬울 뿐 아니라 일반적인 일괄 처리 태스크를 구현하기에 상당히 편하다.

### 중간 상태 구체화

- 분산 파일 시스템 내 잘 알려진 위치에 데이터를 올리면 작업 간 연결이 느슨해 어떤 작업이 입력을 생성하고 출력을 생산하는지 알 필요가 없다.
- 대게 한 작업의 출력은 같은 팀 내에서 유지보수하는 다른 특정 작업의 입력으로만 사용된다. 이 경우 분산 파일 시스템 상에 있는 파일들은 단순히 한 작업에서 다른 작업으로 데이터를 옮기는 수단, 중간 상태다.
- 중간 상태를 파일로 기록하는 과정을 구체화라 한다.
- 파이프는 중간 상태를 완전히 구체화하는 대신 작은 인메모리 버퍼만을 사용해 점진적으로 출력을 입력으로 스트리밍한다.

### 데이터플로 엔진

- 스파크, 테즈, 플링크 : 분산 일괄 처리 연산을 수행하는 엔진, 데이터플로 엔진
	- 전체 워크플로를 독립된 하위 작업으로 나누지 않고 작업 하나로서 다룬다.
	- 단일 스레드에서 사용자 정의 함수를 반복 호출해 한번에 레코드 한 개씩 처리한다.
	- 입력을 파티셔닝해 병렬화한다.
	- 한 함수의 출력을 다른 함수의 입력으로 사용하기 위해 네트워크를 통해 복사한다.
	- 맵과 리듀스를 번갈아 수행하는 식의 규칙을 엄격하게 지킬 필요가 없이, 더 유연한 방법으로 함수들을 조합할 수 있는데 이 함수를 연산자라고 부른다.

### 내결함성

- 분산 파일 시스템에 중간 상태를 모두 구체화할 때 생기는 이점은 내구성이다. 맵리듀스는 중간 상태를 모두 구체화하기 때문에 쉽게 내결함성을 확보한다.
- 스파크, 플링크, 테즈 : 장비가 죽어서 장비에 있던 중간 상태까지 잃게 되면 아직 유효한 데이터러부터 계산을 다시 해서 복구한다.
- 재계산이 가능하려면 어느 입력 파티션을 사용했는지, 어떤 연산자를 적용했는지를 추적해야 한다.
- 아래로 전파되는 결함을 피하려면 연산자를 결정적으로 만드는 것이 좋다.

### 구체화에 대한 논의

- 맵리듀스는 각 명령의 출력을 임시 파일에 기록하는 것과 유사한 반면 데이터플로 엔진은 유닉스 파이프와 매우 비슷하다.
- 데이터플로 엔진을 사용할때 HDFS상에 구체화된 데이터셋은 보통 작업의 입력과 최종 출력이다.
- 사용자가 직접 모든 중간 상태를 파일 시스템에 기록하는 수고를 덜어준다.

### 그래프와 반복 처리

- 페이지랭크 : 웹 페이지를 링크하는 다른 웹페이지를 기반으로 인기도를 측정하는 알고리즘
- 이행적 패쇄 : 한 번에 하나의 간선을 순회하는 방식으로 특정 정보를 전파하기 위해 정점 하나와 인접한 정점을 조인하면서 특정조건에 도달할 때까지 반복한다.
- 반복적 스타일로 구현된다.

### 프리글 처리 모델

- 일괄 처리 그래프를 최적화하는 방법으로 벌크 동기식 병렬(BSP) 연산 모델이 널리 사용된다.
- 맵리듀스와 프리글 모델의 차이점은 정점은 반복에서 사용한 메모리 상태를 기억하고 있다.
- 정점은 새로 들어오는 메시지만 처리한다.


### 내결함성

- 네트워크 상의 문제로 메시지가 사라지거나 중복되거나 지연되더라도 다음 반복에서 메시지는 목적지 정점에서 정확히 한 번만 처리된다.
- 반복이 끝나는 시점에 모든 정점의 상태를 주기적으로 체크포인트로 저장함으로써 보장된다. 전체 상태를 지속성 있는 저장소에 기록한다.

### 병렬 실행

- 그래프 알고리즘은 장비 간 통신 오버헤드가 많이 발생한다.
- 이런 이유로 그래프가 단일 컴퓨터 메모리에 넣을 수 있는 크기라면 단일 장비 알고리즘이 분산 일괄 처리보다 훨씬 성능이 좋을 가능성이 높다.

### 선언형 질의 언어로 전환

- 어떤 조인 알고리즘을 선택하느냐에 따라 일괄 처리 작업의 성능이 크게 달라진다.
- 선언적인 방법으로 조인을 저장하면 가능하다.
