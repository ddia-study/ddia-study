# 10장 - 일괄처리

- 현대 시스템 : 시스템에 요청하거나 지시를 보낸 후 결과를 반환받는 방식
- 이러한 현대 시스템에서 응답 시간 단축에 노력을 많이 기울임
- 시스템을 세가지 유형으로 구분
    - 서비스(온라인 시스템)
        - 클라이언트로부터 요청이나 지시가 올 때까지 기다림
        - 응답시간이 큰 지표
    - 일괄 처리 시스템 (오프라인 시스템)
        - 매우 큰 입력 데이터를 받아 데이터를 처리하는 작업을 수행하고 결과 데이터를 생산
        - 반복적인 일정으로 수행
        - 처리량이 큰 지표
    - 스트림 처리 시스템(준실시간 시스템)
        - 요청에 대해 응답하지 않으며 입력 데이터를 소비하고 출력 데이터를 생산함
        - 정해진 크기의 입력 데이터 대상이 아니라 입력 이벤트가 발생한 직후 작동
        
- 정렬 대 인 메모리 집계
    - 루비 스크립트(책에 설명된)는 URL 해시 테이블을 메모리에 유지, 해시 테이블에 URL이 출현한 수를 매핑 → 인 메모리 집계
    - 유닉스 파이프라인 예제 → 정렬
    - 다른 URL이 얼마나 되느냐에 따라 다름(중소규모의 경우 인 메모리 집계)
    - 큰 규모의 경우 정렬 접근법
        1. 데이터 청크를 메모리에 정렬, 청크를 세그먼트 파일로 디스크에 저장
        2. 세그먼트 파일 여러 개를 한 개의 큰 정렬 파일로 병합
        - 병합 정렬은 순차적인 접근 방식을 따르고 디스크상에서 좋은 성능을 나타냄
- 유닉스 철학
    - 유닉스 파이프 : 다른 방법으로 데이터 처리가 필요할 때 정원 호스와 같이 여러 다른 프로그램을 연결하는 방법이 필요, I/O 방식.
    - 파이프로 프로그램을 연결하는 아이디어
    1. 각 프로그램이 한가지 일만 하도록 작성하라.
    2. 모든 프로그램의 출력은 아직 알려지지 않은 다른 프로그램의 입력으로 쓰일 수 있다고 생각하라
    3. 소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라
    4. 프로그래밍 작업을 줄이려면 미숙한 도움보단 도구를 사용하라
    
- 동일 인터페이스
    - 어떤 프로그램의 출력을 다른 프로그램의 입력으로 쓰기 위해선 같은 데이터 형식 사용해야함
    - 유닉스에서의 인터페이스 = 파일
    - 파일을 통해 IPC, 장치드라이버 /dev/lp0, TCP연결을 나타내는 소켓등 여러가지 것을 표현
    - 많은 유닉스 프로그램이 연속된 바이트를 아스키 텍스트로 취급
    
    +) 동일한 데이터 모델인 데이터베이스 간에도 데이터를 옮기는게 쉽지 않음, 데이터 발칸화(유닉스 같은 통합 부족)
    
- 로직과 연결의 분리
    - 파이프는 한 프로세스의 stdout을 다른 프로세스의 stdin과 연결
    - 위의 과정에서 중간 데이터를 디스크에 쓰지 않고 작은 인메모리 버퍼를 사용해 프로세스간 데이터를 전송(만약 파일이 크다면?)
    - stdin과 stdout을 사용할 때의 제약사항
        - 여러 개의 입출력이 필요할 때 까다로움
        - 프로그램의 출력을 파이프를 이용해 네트워크와 연결하지는 못함
        
- 투명성과 실험
    - 유닉스는 진행 사항을 파악하기 상당히 쉬움
        - 유닉스 명령에 들어가는 입력 파일은 일반적으로 불변으로 처리
        - 어느 시점이든 파이프라인을 중단하고 출력을 통해 확인 가능
        - 특정 파이프라인 단계의 출력을 파일에 쓰고 그 파일을 다음 단계의 입력으로 사용할 수 있음
    - 가장 큰 제약 : 단일 장비에서만 실행됨

---

- 맵리듀스와 분산 파일 시스템
    - 유닉스 도구와 비슷한 면이 있지만 수천 대의 장비로 분산해서 실행이 가능함
    - 순차적으로 한번만 쓰여지고 이미 파일에 쓰여진 부분은 고치지 않는다.
    - 맵리듀스 작업은 분산 파일 시스템상의 파일을 입력과 출력으로 사용(HDFS 하둡 파일시스템)
    - HDFS
        - 비공유 원칙 기반 = NAS(Network Attached Storage), SAN(Storage Area Network)과 반대
        - 공유 디스크 저장소는 집중 중앙 저장 장치를 사용하는데 하드웨어나 파이버 채널과 같은 네트워크 인프라 사용
        - 비공유 방식은 별도 하드웨어 필요 없음
        - 각 장비에서 실행되는 데몬 프로세스로 구성
        - 데몬프로세스는 다른 노드가 해당 장비에 저장된 파일에 접근 가능하게끔 네트워크 서비스를 제공
        - 개념적으로 하나의 큰 파일 시스템 + 데몬이 실행 중인 모든 장비의 디스크를 사용 가능
        - 파일 블록은 여러 장비에 복제됨

- 맵리듀스 작업 실행하기
    - 분산 파일 시스템 위에서 대용량 데이터셋을 처리하는 코드를 작성하는 프로그래밍 프레임워크
    - 데이터 처리 패턴
        1. 입력 파일 읽고 레코드로 쪼갬, 웹 서버 로그에 레코드줄 추가
        2. 각 입력 레코드마다 매퍼 함수를 호출해 키와 값을 추출
        3. 키를 기준으로 키-쌍을 모두 정렬
        4. 정렬된 키-쌍 전체를 대상으로 리듀스 함수를 호출
    - 매퍼
        - 모든 입력 레코드마다 한번씩 호출.
        - 입력 레코드로부터 키와 값을 추출하는 작업
        - 매퍼는 입력 레코드로부터 다음 레코드까지 상태를 유지하지 않고 독립적으로 처리
    - 리듀서
        - 매퍼가 생산한 키-값 쌍을 받아 같은 키를 가진 레코드를 모으고 해당 값의 집합을 반복해 리듀서 함수를 호출
        - 리듀서는 출력 레코드를 생산
        
- 맵리듀스의 분산 실행
    - 유닉스 파이프라인과의 가장 큰 차이는 병렬로 수행하는 코드를 직접 작성하지 않고 여러 장비에서 동시에 처리가 가능.
    - 매퍼와 리듀서가 한 번에 하나의 레코드만 처리하고 신경X
    - 분산 연산에서 매퍼와 리듀서로 표준 유닉스 도구를 사용하는 것 가능, but 일반적인 프로그래밍 언어를 사용
        1. 맵 테스크에서 실행될 애플리케이션 코드로 파일(JAR 등)을 복사,
        2. 장비에서 매퍼 태스크가 시작됨
        3. 한번에 한 레코드 하나씩 읽어 매퍼 콜백 함수로 전달
    - 정렬시 단계를 나누어 정렬을 수행
        1. 키의 해시값을 기반으로 출력을 리듀서로 파티셔닝
        2. 각 파티션을 매퍼의 로컬 디스크에 정렬된 파일로 기록
        3. 매퍼가 파일 기록 완료시 매퍼에서 출력 파일을 가져올 수 있다고 리듀서에게 알려줌
        4. 리듀서가 각 매퍼와 연결해서 담당하는 파티션의 키-값 쌍 파일을 다운로드(셔플)
        
        +) 셔플시 정렬될 순서를 유지하며 병합
        
    - 맵리듀스 워크플로
        - 맵리듀스 작업 하나로 해결할 수 있는 문제의 범위는 제한적, 추가로 정렬 작업이 필요
        - 맵리듀스 작업을 연결해 워크플로로 구성하는 방식
        - 맵리듀스 작업 하나의 출력을 다른 맵리듀스의 작업의 입력으로 사용하는 방식
        - 하둡은 맵리듀스 작업 간 수행 의존성을 관리하기 위해 다양한 스케줄러 사용
    
    - 리듀스 사이드 조인과 그룹화
        - 여러 데이터셋에 한 레코드가 다른 레코드와 연관이 있는 것
        - 데이터 베이스에서는 일반적으로 조인을 사용 + 색인을 통해 빠른 조회(특정 사용자만 찾는 경우 좋음)
        - full scan(전체 테이블 스캔), 대량의 레코드를 대상으로 집계연산을 하는 경우에 합리적인 방법
    
    - 정렬 병합 조인
        - 매퍼 : 입력 레코드로부터 키와 값을 추출하는 것이 목적임
        - 보조 정렬 : 리듀서가 항상 사용자 데이터베이스를 먼저 보고 활동 이벤트를 시간 순으로 보게 하는 식으로 레코드 재배열(?)
            1. 리듀서 함수가 모든 사용자 ID당 한번만 호출 → 첫번째 값은 사용자 데이터베이스의 생열월일 레코드
            2. 다음 부터 같은 사용자 ID가 동일한 활동 이벤트를 순회해본 URL과 연령 쌍을 출력
            
            +) 한번에 한명의 ID를 메모리에 갖고 처리 → 정렬 병합 조인
            
    - 그룹화
        - 맵리듀스에서 그룹화 연산시 그룹화할 대상을 키로
        - 특정 사용자가 취한 일련의 활동을 위해 사용자 세션별 이벤트 수집 →  세션화
    
    - 쏠림 다루기
        - 불균형한 활성 데이터베이스 레코드 ⇒ 린치픽 객체, 핫 키
        - 유명 인사 한 사람에 관련된 모든 활동을 리듀서 한개에서 모으면 상당한 쏠림 현상 → 핫 스팟
        - 이 경우 가장 느린 리듀서가 작업을 완료할 때까지 후속 작업들은 시작하지 못한 채 기다림
        - 쏠린 조인 메서드 : 어떤 키가 핫 키인지 결정하기 위해 샘플링 작업 수행
            - 조인시에는 임의로 여러 리듀서중 하나 선택
            - 핫 키를 여러 리듀서에 퍼뜨려서 처리하게 하는 방법
            1. 맵 리듀스 단계 : 레코드를 임의의 리듀서로 보냄
            2. 각 리듀서는 핫 키 레코드의 일부를 그룹화하고 키별로 집계해 간소화한 값 출력
            3. 모든 리듀서에서 나온 값을 키별로 모두 결합해 하나의 값을 만듬
            
    - 맵 사이드 조인
        - 리듀스 사이드 조인 → 실제 조인  로직을 리듀서에서 수행
        - 매퍼는 입력 레코드의 키 값을 추출해 리듀서 파티션으로 할당
        - 리듀스 사이드 조인
            - 입력 데이터에 대한 특정 가정이 필요 없음
            - 매퍼가 입력 데이터의 속성과 구조가 무엇이든 조인 준비 할 수 있음
            - 정렬 ㅎ 리듀서로 복사한 뒤 리듀서 입력을 병합하는 모든 과정에서 비용이 큼(디스크에 저장)
        - 맵사이드 조인
            - 입력 데이터에 대해 특정 가정이 존재
            - 매퍼가 분산 파일 시스템에서 단순히 입력 파일 블럭 하나를 읽어 다시 해당 분산 파일 시스템에 출력
        
    - 브로드캐스트 해시 조인
        - 브로드 캐스트 : 큰 입력의 파티션 하나를 담당하는 각 매퍼는 작은 입력 전체를 읽음
        - 해시 : 해시 테이블을 사용
        - 작은 조인 입력을 인메모리 해시 테이블로 적재 대신 로컬 디스크에 읽기 전용 색인으로 작은 조인 입력을 저장하기도 함
    - 파티션 해시 조인
    - 맵 사이드 병합 조인
    
    ---
    
- 목적
    - 검색 색인 구축
        - 초창기 구글에서 검색 엔진에 사용할 색인을 구축하기 위해 처음 사용
        - 매퍼가 피룡에 따라 문서 집합을 파티셔닝하고 리듀서가 해당 파티션에 대한 색인을 구축, 색인 파일은 분산 파일 시스템에 저장
    - 일괄 처리 출력에 관한 철학
        - 입력을 불변으로 처리하고 외부 데이터베이스에 기록하는 등의 부수 효과를 피함
            - 코드에 버그가 있어 출력이 오염되면 코드를 이전 버전으로 돌리고 작업을 재수행함
            - 쉽게 되돌릴 수 있는 속성의 결과로 실수를 하면 손상을 되돌릴 수 없는 환경에서보다 기능 개발을 빠르게 진행가능
            - 맵이나 리듀스 태스크 실패시 맵리듀스 프레임워크가 해당 태스크를 자동으로 다시 스케줄링

---

- 하둡과 분산 데이터베이스의 비교
    - MPP 데이터 베이스는 분석 SQL 질의를 병렬로 수행하는 것에 초점, 맵리듀스와 분산 파일 시스템의 조합은 운영체제와 비슷한 속성
    - 저장소의 다양성
        - 데이터 베이스는 특정 모델에 따라 데이터를 구조화해야함
        - 분산 파일시스템의 파일은 연속된 바이트일 뿐
        - 데이터를 모델링하고 가져오는 것이 이상적, 현실에서는 데이터를 ‘빨리’사용하는게 더 가치 있다.
        - “원시 데이터가 더 좋다”
    - 처리 모델의 다양성
        - SQL 질의로 모든 종류의 처리를 표현하지 못한다. (머신러닝, 추천 시스템)
        - 맵리듀스가 너무 제한적이고 성능이 나쁜점이 있어 하둡 위에 다른 다양한 처리 모델 개발됨 → 개방성 덕분
    - 빈번하게 발생하는 결함을 줄이는 설계
        - 일괄처리의 경우 온라인 시스템에 비해 결함에 덜 민감 → 언제든 다시 실행 가능
        - MPP의 경우 결함시 전체 질의 중단, but 맵리듀스는 실패 견딜 수 있음
        

---

- 맵리듀스를 넘어
    - 분산 파일 시스템 상에서 상당히 단순 명료하게 추상화된 모델
    - 중간 상태 구체화
        - 맵리듀스 작업은 다른 작업과 모두 독립적, 주요 접점은 분산 시스템 상의 입력과 출력 디렉터리
        - 한 작업의 출력이 다른 작업의 입력이 되기 전까지의 단계 → 중간 상태
        - 중간 상태를 파일로 기록하는 구체화
        - 파이프 → 중간 상태 구체화 대신 작은 인메모리 버퍼만을 사용해 출력으로 입력을 ‘스트리밍’함
        - 단점
            - 중간 상태 저장을 일종의 임시데이터 중복
            - 매퍼가 종종 중복을 유발
            - 입력을 생성하는 맵리듀스 작업은 모든 선행 작업이 완료됐을때만 시작 가능 → 부하가 한쪽에 쏠림
    - 데이터플로 엔진
        - 일괄 처리 연산 수행하는 엔진이 개발됨
        - 스파크, 테즈, 플링크 → 전체 워크플로를 작업 하나로 다룸
        - 단일 스레드에서 사용자 정의 함수를 반복 호출함
        - 맵 → 리듀스 번갈아 수행 대신 유연한 방법으로 조합하는 함수 → 연산자
        - 연산자의 출력과 다른 연산자의 입력을 데이터플로 엔진이 연결
    - 내결함성
        - 중간 단계를 구체화할 때 생기는 이점, 내구성
        - 장비가 죽어서 장비에 있던 중간 상태까지 잃게 되면 아직 유효한 데이터로부터 계산해서 다시 복구
        - 스파크, 데이터 조상을 추적하기위해 RDD 추상화 사용

---

- 그래프와 반복 처리
- 고수준 API와 언어
    - 기술의 발전으로 대규모의 일과 처리를 운영하는 문제가 거의 해결됨
- 선언형 질의 언어로 변환
    - 질의 최적화기를 통해 중간 상태를 최소화하기 위해 조인 순서를 바꿈
    - 선언적인 방법으로 조인을 지정 → 최적화기가 최적의 수행 방법을 결정
    - 맵리듀스와 맵리듀스의 데이터플로 계승자들은 SQL의 완전 선언형 질의 모델과는 다름
    - 이미지 분석, 자연어 처리, 통계 알고리즘 등을 수행하는 라이브러리의 대규모 생태계가 존재해 활용할 수 있는 장점이 있음
