# 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

계산 중심이 아닌 데이터 중심적


## 데이터 시스템에 대한 생각
---

표준 구성 요소
+ 데이터베이스 : 다시 데이터를 찾을 수 있게 데이터를 저장
+ 캐시 : 읽기 속도 향상을 위해 값비싼 수행 결과를 기억
+ 검색 색인 : 키워드로 데이터를 검색 및 필터링할 수 있게 제공
+ 스트림 처리 : 비동기 처리를 위해 다른 프로세스로 메세지 제공
+ 일괄 처리 : 대량의 누적된 데이터를 분석

데이터 시스템이라는 포괄적 용어로 묶는 이유 
+ 데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어 졌는데, 새로운 도구들은 다양한 use case에 최적화 되었기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않음
+ 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 광범위한 요구사항을 가짐
   + 작업을 단일 도구에서 효율적으로 수행할 수 있는 테스크로 나눔
   + 도구들을 애플리케이션 코드를 이용해 서로 연결


## 신뢰성
---

기대치
+ 애플리케이션은 사용자가 기대한 기능을 수행
+ 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있음
+ 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족
+ 시스템은 허가되지 않은 접근과 오남용을 방지
  

신뢰성 : 무언가 잘못되더라도 지속적으로 올바르게 동작함

결함 : 잘못될 수 있는 일

결함을 예측하고 대처할 수 있는 시스템을 **내결합성** 또는 **탄력성**을 지녔다고 말함

결함은 장애와 동일하지 않음

**결함**은 사양에서 벗아난 시스템의 한 구성 요소로 정의되지만, **장애**는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우

결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋음

고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있는 자신감을 높임


### 하드웨어 결함

시스템 장애율을 줄이기 위해 각 하드웨어 구성 요소에 **중복**을 추가

구성 요소 하나가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용할 수 있음

대부분의 어플리케이션은 하드웨어 구성 요소의 중복으로 충분했음, 하지만 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용하게 됐고

이와 비례해 하드웨어 결함율도 증가함

이러한 이유들로 인해 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있음


### 소프트웨어 오류

시스템 내 쳬계적 오류 : 예상하기가 더 어렵고 노드 간 상관관계 때문에 상관관계 없는 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있음

예시
+ 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
+ CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
+ 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
+ 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애

소프트웨어 결함을 유발하는 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않음

소프트웨어의 체계적 오류 문제는 신속한 해결책이 없음


### 인적 오류

운영자의 설정 오류가 중단의 주요 원인인 반면 하드웨어 결함은 중단 원인의 10~25%에 그침

최고의 시스템은 다양한 접근 방식을 결합
+ 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라, 하지만 인터페이스가 지나치게 제한적이면 사람들은 제한된 인터페이스를 피해 작업함
+ 사람이 가장 많이 실수하는 부분에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라, 실제 사용자에게는 영향이 없는 비 프로덕션 샌드박스를 제공
+ 단위 테스트로부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라, 코너 케이스를 다루는데 유용
+ 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
+ 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라, 문제가 발생했을 때 지표는 문제를 분석하는 데 매우 중요함
+ 조작 교육과 실습을 시행하라


### 신뢰성은 얼마나 중요할까?

비즈니스 애플리케이션에서 버그는 생상성 저하의 원인, 전자 상거래 사이트의 중단은 매출에 손실이 발생하고 명성에 타격을 준다는 면에서 많은 비용이 듬

**중요하지 않은** 애플리케이션도 사용자에 대한 책임이 있음

비용을 줄이려 신뢰성을 희생해야 하는 경우에는 비용을 줄요야 하는 시점을 매우 잘 알고 있어야 함


## 확장성
---

시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없음, 성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가임

**확장성**은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의


### 부하 기술하기 

시스템의 현재 부하를 간결하게 기술해야 부하 성장 질문을 논의할 수 있음

부하는 **부하 매개변수**라 부르는 몇 개의 숫자로 나타낼 수 있음

부하 매개변수
+ 웹 서버의 초당 요청 수
+ 데이터베이스의 읽기 대 쓰기 비율
+ 대화방의 동시 활성 사용자
+ 캐시 적중률
+ 등등


### 성능 기술하기

+ 처리량 : 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간
+ 응답 시간 : 클라이언트가 요청을 보내고 응답을 받는 사이의 시간

**지연 시간과 응답 시간**

+ 지연 시간과 응답 시간은 동일하지 않음
+ 응답 시간은 클라이언트 관점으로 본 시간, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함됨
+ 지연 시간은 요청이 처리되길 기다리는 시간, 서비스를 기다리며 휴지 상태인 시간

응답 시간은 단일 숫자가 아니라 측정 가능한 값의 **분포**로 생각해야 함

보고된 평균 응답 시간을 살필 때 일반적으로 산술 평균보다는 백분위를 사용하는 편이 더 좋음

중앙값은 50분위로서 **p50**으로 축약할 수 있음

특이 값이 얼마나 좋지 않은지 알아보려면 **상위 백분위(꼬리 지연 시간)**를 살펴보는 것이 좋음

이때 사용하는 백분위
+ p95
+ p99
+ p99.9

서비스의 사용자 경험에 직접 영향을 주기 때문에 중요함

백분위는 서비스 수준 목표(SLO)와 서비스 수준 협약서(SLA)에 자주 사용

큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지함

**선두 차단** : 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체됨

**꼬리 지연 증폭** : 작은 비율의 백엔드 호출만 느려도 최종 사용자 요청이 여러 번 백엔드를 호출하면 느린 호출이 발생할 가능성이 증가하고, 최종 사용자 요청 중 많은 비율의 응답 시간이 결국 느려짐


### 부하 대응 접근 방식

확장성
+ 용량 확장 : 수직 확장, 좀 더 강력한 장비로 이동
+ 규모 확장 : 수평 확장, 다수의 낮은 사양 장비에 부하를 분산

다수의 장비에 부하를 분산하는 아키텍처를 **비공유 아키텍처**라 부름

단일 장비에서 수행될 수 있는 시스템은 보통 간단하지만 고사양 장비는 매우 비싸기 때문에 대게 규모 확장을 함

일부 시스템은 탄력적이라 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있음

다수의 장비에 상태 비저장(stateless) 서비스를 배포하는 일은 간단함, 하지만 단일 노드에 상태 저장(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생함

대게 대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특하되어 있음, 범용적이고 모든 상황에 맞는 확장 아키텍처는 없음

아키텍처를 결정하는 요소
+ 읽기의 양
+ 쓰기의 양
+ 저장할 데이터의 양
+ 데이터의 복잡도
+ 응답 시간 요구사항
+ 접근 패턴
  

## 유지보수성
---

소프트웨어 비용의 대부분은 초기 개발이 아닌 지속해서 이어지는 유지보수에 들어감

유지보수
+ 버그 수정
+ 시스템 운영 유지
+ 장애 조사
+ 새로운 플랫폼 적응
+ 새 사용 사례를 위한 변경
+ 기술 채무 상환
+ 새로운 기능 추가

소프트웨어 시스템 설계 원칙
+ 운용성 : 운영팀이 시스템을 원할하게 운영할 수 있게 쉽게 만들어라
+ 단순성 : 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 이해하기 쉽게 만들어라
+ 발전성 : 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라


### 운용성 : 운영의 편리함 만들기

**"좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다"**

시스템이 지속해서 원활하게 작동하려면 운영팀이 필수, 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임짐
+ 시스템 상태를 모니터링 및 서비스 복원
+ 문제의 원인을 추적
+ 소프트웨어와 플랫폼을 최신 상태로 유지
+ 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
+ 발생 가능한 문제를 예측해 문제가 발생하기 전 해결
+ 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
+ 복잡한 유지보수 테스크를 수행
+ 설정 변경으로 생기는 시스템 보안 유지보수
+ 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
+ 시스템에 대한 조직의 지식을 보존
  
  좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만드는 것을 의미

  동일 반복 태스크를 쉽게 하기 위해 아래 항목 등을 포함해 다양한 일을 할 수 있음
  + 런타임 동작과 시스템 내부에 대한 가시성 제공
  + 자동화와 통합을 위한 우수한 지원을 제공
  + 개별 장비 의존성을 회피
  + 좋은 문서, 이해하기 쉬운 운영 모델 제공
  + 기본 동작 제공, 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
  + 자기 회복이 가능하고, 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
  + 예측 가능하게 동작하고 예기치 않은 상황을 최소화 함


### 단순성 : 복잡도 관리

복잡도는 모든 사람의 진행을 느리게 하고 유지보수 비용을 증가시킴

복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상됨, 따라서 단순성이 구축하려는 시스템의 핵심 목표여야 함

우발적 복잡도 : 소프트웨어가 풀어야 할 문제에 내재하고 있지 않고 구현에서만 발생하는 것

우발적 복잡도를 제거하기 위한 최상의 도구는 **추상화**, 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있음


### 발전성 : 변화를 쉽게 만들기

시스템의 요구사항이 영원히 바뀌지 않을 가능성은 매우 적음

조직 프로세스 측면에서 **에자일** 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공함, 에자일 커뮤니티는 테스트 주도 개발(TDD), 리팩토링 같이 자주 변화하는 환경에서 

소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있음

데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있음