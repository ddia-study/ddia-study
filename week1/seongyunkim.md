# 01. 신뢰성, 확장성, 유지보수성

## 개요

- 1부: 데이터 시스템의 기초
    - 신뢰성, 확장성, 유지보수성
    - 데이터 모델, 질의어
    - 저장 엔진
    - 데이터 직렬화
- 2부: 분산 데이터
    - 복제
    - 파티셔닝, 샤딩
    - 트랜잭션
    - 일관성, 합의
- 3부: 파생 데이터
    - 일괄 처리
    - 스트림 처리
    

데이터 중심 애플리케이션: CPU 속도보다는 데이터 양, 복잡도, 변화 속도에 영향

- (공통으로 필요로 하는)표준 구성 요소
    - Database: 데이터를 다시 찾을 수 있도록 저장
    - Cache: 값 비싼 수행 결과를 기억해 속도 향상
    - Search index: 데이터 검색, 필터링
    - Stream processing: 비동기 처리를 위해 다른 프로세스로 메시지 보내기
    - Batch Processinig: 주기적으로 누적된 데이터 분석
    

## 데이터 시스템에 대한 생각

- 새로운 데이터 시스템 (Redis, Kafka...)들은 특정 사용 사례에 최적화
- 광범위한 요구사항을 단일 도구에서 수행할 수 있는 태스크로 나누고 애플리케이션에서 연결 (동기화된 캐시, 색인)
- 개발자는 애플리케이션 개발자 뿐만 아니라, 데이터 시스템 설계자
- 소프트웨어 시스템의 주요 관심사
    - 신뢰성: 역경에 직면하더라도 시스템은 올바르게 동작해야(성능, 기능)
    - 확장성: 데이터, 트래픽의 양/복잡도가 증가해도 처리할 수 있는 적절한 방법이 있어야
    - 유지보수성: 모든 사용자가 생상적으로 작업할 수 있어야

## 신뢰성

- 무언가 잘못되더라도 지속적으로 (결함으로 인해 장애가 발생하지 않게끔)
    - 기대한 기능을 수행
    - 사용자의 실수나 예상치 못한 사용을 허용
    - 예상된 부하에서 성능 만족
    - 허가된지 않은 오남용 방지
- 고의적으로 결함을 유도해 내결함성을 훈련하고 결함이 자연적으로 발생했을 때 올바르게 처리하도록 ([Netflix Chaos Monkey](https://github.com/Netflix/chaosmonkey))

### 하드웨어 결함

- 하드웨어 결함 시 장애율을 줄이기 위한 방법: 중복을 추가해 결함 시 대신 사용
    - 디스크 RAID, 서버 이중 전원 디바이스, 한 스왑 CPU, 예비용 발전
    - 신뢰성보다 유연성, 탄력성이 우선인 클라우드 환경에서 필요

### 소프트웨어 오류

- 예시
    - 잘못된 특정 입력이 있을 때 인스턴스가 죽는 버그
    - CPU, 메모리, 디스크, 대역폭 등 자원을 과도하게 사용하느 프로세스
    - 시스템 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
    - 연쇄 장애
- 신속한 해결책은 없음
    - 시스템의 가정과 상호작용에 대한 주의 깊은 생각
    - 빈틈없는 테스트
    - 자동 재시작
    - 모니터링 및 로깅

### 인적 오류

- 오류 가능성을 최소화 하는 설계 (적절한 추상화 인터페이스)
- 사람이 실수하는 장소에 테스트 환경
- Unit, Integration 테스트 자동화
- 빠른 롤백, 점진적인 배포
- 성능 지표 모니터링 및 대책

## 확장성

- 증가한 부하에 대처하는 시스템 능력 (성능 저하의 큰 이유는 부하 증가)
- 시스템이 특정 방식으로 커지면 대처하기 위한 선택은 무엇인가?
- 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?

### 부하 기술하기

- 시스템의 현재 부하를 간결하기 기술 (부하 매개변수)
    - 웹 서버 초당 요청 수, DB 읽기 쓰기 비율, 동시 활성자수, 캐시 적중률
- 트위터 예시
    - 개별 사용자가 많은 사람을 팔로우, 많은 사람이 개별 사람을 팔로우 (팬 아웃)
    - 트윗 게시 요청량이 타임라인 읽기 요청량보다 수백 배 적음 → 쓰기 시점에 더 많은 일 (각 사용자의 타임라인 캐시를 유지)
    - 그러나, 팔로워가 많은 사용자가 트윗을 게시했을 때 전송 작업이 무거워짐 (사용자당 팔로워 수가 핵심 부하 매개변수)

### 성능 기술하기

- 시스템 성능
    - 처리량(throughput): 초당 처리할 수 있는 데이터 양, 작업을 수행할 때 걸리는 전체 시간
    - 응답 시간(response time): 클라이언트가 요청을 보내고 응답을 받는 사이 시간 (요청 처리 실제 시간 + 네트워크 지연 등)
    - 지연 시간(latency): 요청이 처리되길 기다리는 (휴지 상태) 시간
- 다양한 지표
    - 평균
    - 중앙값 (p50): 사용자가 “보통” 얼마나 오랫동안 기다리는가
    - 상위 백분위 (p95, p99, p999): 특이값이 얼마나 좋지 않은가
        - 꼬리 지연 시간의 중요성
            - 응답 시간이 느린 사용자가 많은 데이터를 가지고 있는 주요 고객임
            - 그러나, 최적화하는 작업에 비용이 큼

### 부하 대응 접근 방식

- 확장 방법
    - Scale up: 강력한 장비로. 간단하지만 높은 금전적 비용
    - (Elastic) Scale out: (부하를 감지하면) 장비를 추가해 부하 분산. Stateless 서비스에 적합
- one-size-fits-all 확장 아키텍처는 없음
    - 읽기 양, 쓰기 양, 데이터 양, 데이터 복잡도, 응답 시간 요구사항 등 다양한 고려 요소
    - 스타트업 초기 단계에서는 부하 대비 확장보다는 빠른 반복 및 기능 개선이 중요할 수도

## 유지보수성

- 초기 개발보다 유지보수에 더 많은 비용이 발생 (레거시 시스템)
- 소프트웨어 설계 원칙
    - 운용성: 운영이 쉽도록
    - 단순성: 복잡도를 낮춰 새로운 엔지니어가 이해하기 쉽도록
    - 발전성: 이후에 쉽게 변경할 수 있도록

### 운용성: 운영의 편리함 만들기

- 좋은 운영은 필수. 자동화. 그러나 자동화 동작을 확인하는 것은 사람의 몫
- 운영팀의 책임
    - 시스템 상태 모니터링 및 문제 원인 추적
    - 소프트웨어와 플랫폼을 최신 상태로 유지 (그때 그때)
    - 배포를 위한 도구 마련
    - 개인 인사 이동에도 조직의 지식을 보존 (문서화)

### 단순성: 복잡도 관리

- 복잡도의 증상 → 숨겨진 가정과 예상치 못한 결과로 인한 버그
    - 상태 공간의 급증(?)
    - 모듈간 강한 커플링
    - 복잡한 의존성
    - 일관성 없는 네이밍
    - 임시방편 특수 사례 (하드 코딩)
- 추상화를 통한 (우발적) 복잡도 해결
    - 직관적으로 세부 구현을 숨기기
    - 재사용

### 발전성: 변화를 쉽게 만들기

- 요구사항은 끊임 없이 바뀐다
    - 애자일, TDD, 리팩토링
- 간단함, 추상화와 밀접한 관련

### ⇒ 신뢰성, 확장성, 유지보수성의 간단한 해결책은 없음. 재현되는 특정 패턴과 기술이 있을 뿐
