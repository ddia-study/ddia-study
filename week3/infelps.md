# 저장소와 검색

- 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택해야 함

- 로그 : 추가 전용 데이터 파일
- 색인 : 특정 키의 값을 효율적으로 찾기 위한 데이터 구조
  - 부가적인 메타데이터를 유지
  - 쓰기 과정에서의 오버헤드 발생

---

- 해시 색인
  - 키-값 저장소 : 사전 타입과 유사
  - 디스크 공간이 부족해지는 것을 해결하기 위해 특정 크기의 세그먼트로 로그를 나눔
  - 컴팩션 : 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지

  - 구현에서 중요한 문제
    - 파일 형식
    - 레코드 삭제
    - 고장 복구
    - 부분적으로 레코드 쓰기
    - 동시성 제어
  
  - 제한 사항
    - 키가 너무 많으면 문제 발생
    - 범위 질의에 X

  - 추가 전용 설계 장점
    - 순차적인 쓰기 작업이기 때문에 보통 무작위 쓰기보다 훨씬 빠름
    - 동시성과 고장 복구가 훨씬 간단함
    - 세그먼트 병합을 통해 데이터 파일의 조각화를 피할 수 있음

---

- SS테이블 : 키-값 쌍을 키로 정렬, 정렬된 문자열 테이블
  - 장점
    - 간단하고 효율적, 병합정렬 알고리즘과 유사
    - 모든 키의 색인을 유지할 필요가 없음
    - 압축
  
- 저장소 엔진 만드는 과정
  - 쓰기가 들어오면 멤테이블에 추가
  - 멤테이블이 임곗값보다 커지면 SS테이블 파일로 디스크에 기록
  - 읽기 요청을 : 멤테이블에서 키를 찾음 -> 가장 최신 세그먼트에서 찾음 -> 2번째, 3번째 ...
  
- LSM(로그 구조화 병합 트리) 저장소 엔진 : 정렬된 파일 병합, 컴팩션 원리 기반

- 블룸 필터 : 원소가 집합에 속하는지 여부를 검사하는데 사용되는 확률적 자료 구조 
- 크기 계층 컴팩션 : 새롭고 작은 테이블 -> 오래되고 큰 테이블
- 레벨 컴팩션 : https://github.com/facebook/rocksdb/wiki/Leveled-Compaction

---

- B 트리
  - https://mommoo.tistory.com/108
  - 분기 계수(Branching Factor) : 한 페이지에서 하위 페이지를 참조하는 수
  - 균형을 유지하는 것을 보장
  - 깊이 : O(log n)
  - 새로운 데이터를 디스크 상의 페이지에 덮어씀
  - WAL(쓰기 전 로그) : 변경된 내용을 적용하기 전 변경사항을 기록하는 추가 전용 파일
  - 래치(latch) : 동시성 제어
  - 최적화
    - 쓰기 시 복사 방식
    - 전체 키 대신 키를 축약해 사용
    - 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치
    - 트리에 포인터 추가
    - 프랙탈 트리 : https://gywn.net/2014/05/fractal-index-in-tokudb/

---

- LSM 트리
  - ![screenshot](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fxz43O%2Fbtq0iA912Bs%2FhKWkbMiLF9mu4CwCNkcr1K%2Fimg.png)
  - 장점
    - 쓰기 증폭 : 쓰기 한 번이 여러 번의 쓰기를 야기하는 효과
    - 쓰기 처리량을 높게 유지할 수 있음
    - 압축률이 좋음
  - 단점
    - 컴팩션 과정이 읽기 쓰기 과정에 영향을 줄 수 있음
    - 높은 쓰기 처리량 -> 더 많은 디스크 대역폭
    - 같은 키의 다중 복사본이 존재 가능

---

- 기타 색인 구조
  - 힙 파일 : 특정 순서 없이 데이터를 저장
  - 클러스터드 색인 : 색인 안에 바로 색인된 로우를 저장
    - 읽기 성능 향상
    - 쓰기 과정에서의 오버헤드
  - 결합 색인 : 하나의 키에 여러 필드를 단순히 결합
  - 전문 검색 : 동의어로 질의를 확장
  - 레벤슈타인 오토마탄 https://juggernaut.tistory.com/entry/%EB%A0%88%EB%B2%A4%EC%8A%88%ED%83%80%EC%9D%B8-%EC%98%A4%ED%86%A0%EB%A7%88%ED%83%80Levenshtein-Automata

  - 인메모리 데이터베이스 
    - 안티 캐싱 접근 방식 : 가장 최근에 사용하지 않은 데이터를 메모리에서 디스크로 보냄
    - 비휘발성 메모리

---

- 트랜잭션
  - 온라인 트랜잭션(OLTP) : 일부 키에 대한 적은 수의 레코드를 찾음
  - 온라인 분석 처리(OLAP) : 많은 수의 레코드를 스캔해 레코드당 일부 칼럼만 읽어 집계 통계 계산
  - 표 3-1

- 데이터 웨어하우스 : OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스
  - 그림 3-8
  - 별 모양 스키마(차원 모델링)
    - 사실 테이블 : 별 모양 스키마의 중심에 있는 테이블
    - 차원 테이블 : 사실 테이블에서 값을 한정해 보여주는 테이블

---

- 칼럼 지향 저장소
  - 로우 지향 방식으로 데이터를 배치
  - 모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저장
  - 로우가 모두 같은 순서임에 의존

- 칼럼 압축
  - 비트맵 부호화 그림 3-11
  - n개의 고유 값 칼럼 -> n개의 개별 비트맵
  - 런 렝스 부호화 : 데이터에서 같은 값이 연속해서 나타나는 것을 그 개수와 반복되는 값만으로 표현

- 벡터화 처리 : 한 번에 처리하는 데이터의 양을 늘려서 CPU 사용률을 높이고, 처리속도를 빠르게 하는 기법
- 칼럼 저장소의 순서 정렬
  - 특정 범위의 데이터를 그룹화하거나 필터링하는 질의에 도움이 됨
  - 칼럼 압축에 도움이 됨

- 다양한 순서 정렬
  - 같은 데이터를 다양한 방식으로 정렬해 저장
  - 서로 다른 방식으로 정렬하여 저장하면 질의 패턴에 가장 적합한 버전을 찾을 수 있음

- 칼럼 지향 저장소에 쓰기
  - LSM 트리를 통해 쓰기 문제 해결

- 구체화 집계
  - 질의가 자주 사용하는 일부 카운트나 합을 캐시
  - 구체화 뷰
    - 디스크에 기록된 질의 결과의 실제 복사본
    - 가상뷰는 단지 질의를 작성하는 단축키
  - 데이터 큐브(OLAP 큐브)
    - 특정 질의를 미리 계산했기 때문에 해당 질의를 수행할 떄 매우 빠름
    - 유연성이 없음
    - 대부분의 데이터 웨어하우스는 많은 원시 데이터를 유지하려고 노력

- 정리
  - OLTP와 OLAP의 차이