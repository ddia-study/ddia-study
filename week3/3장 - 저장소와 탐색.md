# 3장 - 저장소와 탐색

- DB의 기본 2 작업 - 데이터 저장 & 데이터 제공
- 데이터 베이스 관점에서 1. 저장하는 방법, 2. 다시 찾는 방법
- 저장소 엔진을 선택할 대 내부 수행 작업을 이해하면 선정하는데 용이

- 데이터 베이스를 강력하게 만드는 데이터 구조
    - 로그 - 연속된 추가 전용 레코드
    - 색인(index) - 특정 키의 값을 효율적으로 찾기 위한 구조
        - 부가적인 메타데이터 유지
        - 색인 작업은 데이터 쓰기의 성능 다운(추가적인 쓰기가 발생하므로)
            - ⇒ 읽기 질의 속도 vs 쓰기 속도 (trade off)
        - 주로 수동으로 색인을 선택
        - 해시 색인
            
            키 - 값 저장소 =(유사) dictionary → hashmap으로 구현
            
            - byte offset 방식 : value 가 시작하는 위치의 byte offset과 key를 매칭해서 색인으로 사용
            - 파일에 추가 지속 → 디스크 공간 부족 → 세그먼트로 로그를 나눔 → 세그먼트들에 대해 컴팩션(중복 키 제거 + 최신 갱긴 값만 유지)
            - 컴팩션은 백그라운드에서 수행( 병합은 새로운 세그먼트에 만듬으로 중간에 읽기에 지장 X) ( page cache dirty 처리 로직, GC)
            - 조회시 : 최신 세그먼트 해시 맵 → 다음 세그먼트 해시 맵 → ...
            - 구현 중요 사항
                - 파일 형식 : 바이너리 형식 사용(문자열 길이 부호화(encoding) → 원시 문자열 부호화)
                - 레코드 삭제 : 특수한 삭제 레코드를 추가, 병합 과정에서 처리
                - 고장 복구 : 새로 해시 맵 복원은 오래 걸림 → 비트캐스크(저장소 엔진 중 하나)에서는 스냅숏을 디스크에 저장
                - 부분적으로 레코드 쓰기 : 레코드 삽입 시 die → 체크섬으로 손상됨 부분 탐지
                - 동시성 제어 : 하나의 쓰기 스레드 + 읽기 멀티스레드
            - 추가 전용 로그의 장점
                - 추가, 세그먼트 병합은 순차 쓰기 이므로 무작위 쓰기 보다 빠름
                - 동시성과 고장 복구가 간단하다.
                
                ← Q1
                
                ← Q2
                
            - 추가 전용 로그의 제한 사항
                - 키가 많으면 해쉬 맵을 메모리에 저장하기 힘듬 → 디스크로 옮기면 무작위 IO 많이 필요
                - 디스크가 가득 찼을 때 확장 비용 비쌈 + 해시 충돌 해소 로직 필요
                - 해시 테이블은 범위 질의에 효과적이지 않음 → 모든 키를 조회
            - 비트 캐스트 에서 사용
        - SS 테이블과 LSM 트리
            - SS 테이블 + LSM 트리 : 로그 구조화 저장소에서 키-값 쌍을 키로 정렬 ⇒ 정렬된 문자열 테이블(Sorting String Table)
                - 세그 먼트 내에서는 키 중복 X , 여러 세그 먼트에 중복 키 → 최신 세그먼트 값만 가짐
                - 장점
                    - 세그먼트 병합이 메모리가 크더라도 효율적 → merge sort 알고리즘과 유사
                    - 특정 키를 찾기 위해 모든 키를 알 필요 없음 (정렬되어 있기 때문) → head 2개 비교해서 사이만 찾으면 됨
                    - 디스크 공간 절약 - 디스크에 쓰기 전에 레코드들을 블록으로 그룹화하고 압축
                - 데이터를 키로 정렬하는 방법?
                    - 멤테이블 = 인 메모리 균형 트리 구조, SS 테이블 파일(세그먼트)는 디스크로
                    - 읽기 시 : 멤 테이블에서 키 찾기 → 최신 세그먼트 탐색 → 다음 세그먼트 → ..
                    - 메모리 날라가는 경우를 위해 분리된 로그를 디스크 상에 유지
                - 레벨 DB, 카산드라, HBase, 록스 DB, 어플 내장형 키-값 저장소 엔진 라이브러리에서 사용
            - 성능 최적화
                - LSM 트리 알고리즘 - 데이터베이스에 존재하지 않는 키를 찾을 경우 느림 → 블룸 필터 사용
                - 압축하고 병합하는 순서와 시기를 결정하는 전략
                    - 크기 계층 : 상대적으로 좀 더 새롭고 작은 SS 테이블을 상대적으로 오래됐고 큰 SS 테이블에 연이어 병합함
                    - 레벨 컴팩션 : 키 범위를 더 작은 SS 테이블로 나누고 오래된 데이터는 개별 “레벨”로 이동
            - 신뢰 가능한 B 트리
                - 쓰기전 로그 (Write Ahead Log) : 트리 페이지에 변경된 내용을 적용하기 전에 모든 B트리의 변경 사항을 추가로 기록
                - 동시성 제어 - 래치 : 백그라운드에서 병합을 수행하고 새로운 세그먼트 교체시에만 원자적 lock 사용
            
            - B 트리 최적화
                - 쓰기 시 복사 (copy on write) : 리소스가 복사 되어도 유지하다가 리소스의 변경이 생기면 복사본을 만들어 각기 다른 곳을 참조.
                - 페이지에 전체 키를 저장하지 않고 키를 축약해 사용
                - 트리에 포인터를 추가하여 양쪽 형제 페이지에 대한 참조 → 속도 빨라짐
            
            - B 트리 vs LSM 트리
                - 쓰기 속도 : B 트리 < LSM 트리
                - 읽기 속도 : B 트리 > LSM 트리 (컴팩션 단계 데이터 구조 + SS 테이블 확인)
            
            - LSM 트리의 장점
                - 쓰기 처리량이 높음 : 순차적으로 컴팩션된 SS 테이블을 사용
                - 압축률이 좋음 : SS테이블을 주기적으로 다시 기록
            - LSM 트리의 단점
                - 컴팩션 과정이 읽기와 쓰기 성능에 영향을 줌
                    - lock 대기, 쓰기 대역폭은 고정인데 유입 쓰기 + 컴팩션이 공유 하므로 컴팩션이 느려질 수 있음(유입 쓰기는 빠름)
            
            - B 트리의 장점
                - 키가 색인 한 곳에만 존재
                - 아키텍처에 뿌리 깊게 내려졌기에 많은 workload에 지속적으로 좋은 성능
            
            - 전문 검색과 퍼지 색인
                - 모호한(fuzzy) 질의, 유사한 키의 검색의 경우
                - 전문 검색 앤진 : 단어의 동의어로 질의 를 확장
- 트랜잭션 처리나 분석
    - 온라인 트랙잭션 처리(OLTP) : 사용자가 어플리케이션을 통해 일부 키에 대해 적은 수의 레코드를 찾음
    - 온라인 분석 처리(OLAP) : 데이터 분석용 트랜잭션(통계 ,..)
    - 데이터 웨어 하우스 : OLTP 시스템을 분석 목적으로 사용하지 않고 개별 데이터 베이스에서 분석 수행할 때의 DB
    - ETL(Extract-Transform-Load) : OLTP 추출 → 친화적인 스키마로 변환 → 웨어하우스에 적재
    - 분석용 스키마
        - 별 모양 스키마(차원 모델링)
            - 테이블의 각 로우는 이벤트를 나타냄
            - 중심에 사실 테이블 → 주위의 차원 테이블
            - 차원 테이블은 이벤트 속성 누가, 언제, 어디서, 무엇을, 어떻게, 왜를 나타냄
            - 눈꽃송이 모양 스키마 → 차원이 하위 차원으로 세분화됨
        - 칼럼 지향 저장소
            - 모든 값을 하나의 로우에 함께 저장하지 않고 각 칼럼별로 모든 값을 함께 저장
            - 압축에 적합(비트맵 부호화)
        
    
- 정리
    - 저장소 엔진은 2가지로 분류됨 : OLTP - 일반 사용자 요청 , OLAP - 분석
    - OLTP의 2가지 주요한 관점
        - 로그 구조화 관점 : 파일에 추가와 오래된 파일의 삭제O, 갱신 X → LSM 트리, SS 테이블, 레벨 DB ,..
        - 제자리 갱신 과점 : 덮어쓰기 할 수 있는 고정 크기 페이지의 셋으로 다룸 → B 트리를 사용하는 많은 DB들

---

Q1. 왜 추가 전용 로그는 순차 쓰기 일까? (병합시 삭제된 세그먼트 → 단편화 → 순차쓰기?)

Q2 . 왜 순차 쓰기는 무작위 쓰기 보다 빠를까? 과연 SSD에서도?

Q3. SSD에서의 Read Write?