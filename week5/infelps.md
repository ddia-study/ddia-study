# 분산 데이터

- 여러 장비 간 분산된 데이터베이스를 필요로 하는 이유
  - 확장성 : 부하를 여러 장비로 분배할 수 있음
  - 내결함성/고가용성 : 장비 하나가 죽더라도 여러 장비를 사용해 중복성을 제공할 수 있음
  - 지연시간 : 사용자와 지리적으로 가까운 곳의 데이터센터에서 서비스를 제공

- 고부하로 확장
  - 수직 확장/용량 확장 : **공유 메모리 아키텍처**에서는 모든 구성 요소를 단일 장비처럼 다룰 수 있음
    - 비용이 선형적인 추세보다 훨씬 빠르게 증가함
    - 제한적인 내결함성 제공 : 핫 스왑 가능(장비를 중단시키지 않고 교체할 수 있음), 하나의 지리적인 위치로 제한
  - 공유 디스크 아키텍처 : 독립적인 CPU, RAM 사용, 디스크 배열 공유
    - 잠금 경합, 오버헤드가 확장성을 제한

- 비공유 아키텍처
  - 수평 확장/규모 확장
  - 노드 : 각 장비, 가상 장비
    - CPU, RAM, 디스크를 독립적으로 사용
    - 코디네이션(coordination)은 일반적인 네트워크를 사용해 소프트웨어 수준에서 수행
  - 가격 대비 성능이 가장 좋은 시스템
  - 부가적인 애플리케이션 복잡도 야기, 사용할 수 있는 데이터 모델의 표현을 제한

- 복제 대 파티셔닝
  - 복제
    - 같은 데이터의 복사본을 잠재적으로 다른 위치에 있는 여러 노드에 유지
    - 중복성을 제공
  - 파티셔닝
    - 큰 데이터베이스를 파티션이라는 작은 서브넷으로 나누고 각 파티션은 각기 다른 노드에 할당(샤딩)
  
# 복제

- 복제 : 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지
  - 필요한 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄임
    - 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높임
    - 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘림
  - 복제에서 모든 어려움은 복제된 데이터의 **변경 처리**에 있음
  - 단일 리더(single-leader), 다중 리더(multi-leader), 리더 없는(leaderless) 복제

- 리더와 팔로워
  - 복제 서버(replica) : 데이터베이스의 복사본을 저장하는 각 노드
  - 리더 기반 복제(leader-based replication) 
    - 복제 서버 중 하나를 리더(leader)로 지정
    - 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 함
    - 리더는 먼저 로컬 저장소에 새로운 데이터를 기록
    - 다른 복제 서버는 팔로워(follower)
    - 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)/변경 스트림(change stream)로 전송
    - 각 팔로워가 복사본을 갱신
  
- 동기식 대 비동기식 복제
  - 그림 5-2
    - 팔로워1 : 동기식
    - 팔로워2 : 비동기식
  - 동기식
    - 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지고 있는 것을 보장
    - 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없음
  - 반동기식
    - 팔로워 하나는 동기식, 그 밖에는 비동기식
  - 비동기식
    - 아직 복제되지 않은 모든 쓰기는 유실, 지속성을 보장하지 않음
    - 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있음
    - 많은 팔로워가 있거나 지리적으로 분산됐다면 널리 사용

- 새로운 팔로워 설정
  - 팔로워 설정 과정
    1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져옴
    2. 스냅숏을 새로운 팔로워 노드에 복사
    3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청, 리더의 복제 로그의 정확하 위치(로그 일련번호, 이진로그 좌표)
    4. 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을때 따라잡았다고 말함

---

- 팔로워 장애 : 따라잡기 복구
  - 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아냄
  - 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청

- 리더 장애 : 장애 복구
  - 장애 복구(failover)
    1. 리더가 장애인지 판단 : 단순히 타임아웃을 사용
    2. 새로운 리더를 선택 : 선출과정, 제어 노드에 의해
    3. 새로운 리더 사용을 위해 시스템을 재설정

  - 잘못될 수 있는 것 투성
    - 비동기식 복제를 사용한다면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수신하지 못할 수 있음
    - 쓰기를 폐기하는 방법은 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정돼야 한다면 위험함
    - 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있음(스플릿 브레임)
    - 타임아웃 설정 문제

---

- 구문 기반 복제
  - 리더는 모든 쓰기 요청(**구문(statement)**)을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송
  - 복제가 깨질 수 있는 사례
    - 비결정적 함수를 호출하는 모든 구문은 서버마다 다른 값을 생성할 가능성이 있음
    - 자동증가 칼럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존하는 구문은 각 복제 서버에서 정확히 같은 순서로 실행되야 함
    - 부수 효과를 가진 구문은 부수 효과가 완벽하게 결정적이지 않으면 다른 부수 효과가 발생할 수 있음
  
- 쓰기 전 로그 배송
  - 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있음
  - 복제가 저장소 엔진과 밀접하게 엮임 -> 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없음

- 논리적(로우 기반) 로그 복제
  - 논리적 로그(logical log) : 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열
    - 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함
    - 삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함
    - 갱신된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값을 포함
  - 하위 호환성을 더 쉽게 유지할 수 있음

- 트리거 기반 복제
  - 애플리케이션 로직을 적용해 데이터 변경을 복제
  - 많은 오버헤드
  - 유연성 때문에 매우 유용

---

- 복제 지연 문제
  - 읽기 확장(read-scaling) : 팔로워 간 읽기 요청을 분산
  - 최종적 일관성 : 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 결국 따라잡게 되고 리더와 일치하게 됨

- 자신이 쓴 내용 읽기
  - 쓰기 후 읽기 일관성 : 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장
  - 디바이스 간 쓰기 후 읽기 일관성 

- 단조 읽기(monotonic read)
  - 시간이 거꾸로 흐르는 현상 : 그림 5-4
  - 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않음

- 일관된 순서로 읽기
  - 그림 5-5
  - 쓰기를 읽는 모든 사용자가 같은 순서로 쓰여진 내용을 보개 됨을 보장
  - 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제

---

- 다중 리더 복제
  - 쓰기를 허용하는 노드가 하나 이상

- 다중 데이터센터 운영
  - 그림 5-6
  - 성능
  - 데이터센터 중단 내성
  - 네트워크 문제 내성

- 오프라인 작업을 하는 클라이언트
  - 모든 디바이스에 리더처럼 동작하는 로컬 데이터베이스가 존재
  - 다중 리더 복제를 비동기 방식으로 수행

- 협업 편집
  - 문서의 잠금을 얻음
  - 변경 단위를 매우 작게해서 잠금을 피할 수 있음 -> 다중 리더 복제에서 발생하는 모든 문제를 야기

- 쓰기 충돌 다루기
  - 그림 5-7

---

- 충돌 회피
  - 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않음

- 일관된 상태 수렴
  - 데이터베이스는 수렴(convergent) 방식으로 충돌을 해소해야 함
  - 수렴 충돌 해소
    - 각 쓰기에 고유 ID를 부여하고 가장 높은 ID를 가진 쓰기를 고름, 최종 쓰기 승리(타임스탬프를 사용하는 경우)
    - 각 복제 서버에 고유 ID를 부여
    - 어떻게든 값을 병합
    - 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존

- 사용자 정의 충돌 해소 로직
  - 애플리케이션 코드를 사용해 충돌 해소 로직을 작성
  - 쓰기 수행 중
    - 충돌을 감지하자마자 충돌 핸들러를 호출
  - 읽기 수행 중
    - 충돌을 감지하면 모든 충돌 쓰기를 저장

- 자동 충돌 해소
  - 충돌 없는 복제 데이터타입
  - 병합 가능한 영속 데이터 구조
  - 운영 변환

- 다중 리더 복제 토폴로지
  - 복제 토폴로지 : 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로
  - 그림 5-8
  - 전체 연결 : 모든 리더가 다른 모든 리더에게 전송
  - 원형 토폴로지 : 각 노드가 하나의 노드로부터 쓰기를 받고, 이 쓰기를 다른 한 노드에게 전달
  - 별 모양 토폴로지 : 지정된 루트 노드 하나가 다른 모든 노드에 쓰기를 전달
  - 원형, 별 : 쓰기는 거치는 모든 노드의 식별자가 태깅됨
  - 전체 : 일부 메시지가 다른 메시지를 추월할 수 있음, 버전 벡터

---

- 리더 없는 복제
  - 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식
  - 다이나모(아마존))

- 노드가 다운됐을 때 데이터베이스에 쓰기
  - 리더 없는 설정에서는 장애 복구가 필요하지 않음
  - 그림 5-10
  - 읽기 요청을 병렬로 여러 노드에 전송
  - 버전 숫자를 사용해 어떤 값이 최신 내용인지 결정

- 읽기 복구와 안티 엔트로피
  - 읽기 복구 : 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있음
  - 안티 엔트로피 처리 : 백그라운드 프로세스가 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 복사함

- 읽기와 쓰기를 위한 정족수
  - 정족수 읽기와 쓰기
    - n개의 복제 서버, w개의 노드에서 성공, r개의 노드에 질의
    - w+r>n이면 읽을 때 최신 값을 얻을 것으로 기대
  - w&lt;n : 노드 하나를 사용할 수 없어도 쓰기를 처리할 수 있음
  - r&lt;n : 노드 하나를 사용할 수 없어도 읽기를 처리할 수 있음

- 정족수 일관성의 한계
  - w+r>n 인 경우에도 오래된 값을 반환하는 에지 케이스 존재
  - 오래된 값을 읽는 확률을 조정할 수 있지만 이를 절대적으로 보장할 수는 없음

- 최신성 모니터링
  - 리더 기반 복제 -> 각 노드가 복제 로그의 위치(로컬에 적용된 쓰기 수)를 가짐
  - 리더 없는 복제 -> 쓰기가 적용된 순서를 고정할 수 없음

- 느슨한 정족수와 암시된 핸드오프
  - 느슨한 정족수 
    - 일단 쓰기를 받아들이고 값이 보통 저장되는 n개의 노드에 속하지는 않지만 연결할 수 있는 노드에 기록
    - 쓰기 가용성을 높이는 데 유용
    - w+r>n인 경우에도 키의 최신 값을 읽는다고 보장하지 않음
  - 암시된 핸드오프 
    - 네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 "홈" 노드로 전송

---

- 동시 쓰기 감지
  - 그림 5-12
  - 키의 값을 단순하게 덮어 쓴다면 일관성이 깨짐

- 최종 쓰기 승리(동시 쓰기 버리기)
  - 예전 값을 버리고 가장 최신 값으로 덮어쓰는 방법
  - 제일 큰 타임스탬프를 선택
  - 최종적 수렴 달성이 목표지만 지속성을 희생
  - 안전하게 쓰는 유일한 방법 : 키를 한번만 사용한 후 불변 값

- "이전 발생" 관계와 동시성
  - 인과성이 있다(casually dependent) : A의 삽입이 B의 증가 이전에 발생
  - 이전 발생(happens-before) : 작업 B가 A를 기반으로 한다면 작업 A는 작업 B의 이전 발생
  - 동시 작업 : 어느 작업도 다른 작업에 대해 알지 못함

- 이전 발생 관계 파악하기
  - 서버가 모든 키에 대한 버전 번호를 유지하고 키를 기록할 때마다 버전 번호를 증가시킴
  - 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환
  - 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고 이전 읽기에서 받은 모든 값을 함께 합쳐야 함
  - 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있음, 이보다 높은 버전 번호의 모든 값은 유지해야 함

- 동시에 쓴 값 병합
  - 형제(sibling) 값 : 동시에 쓴 값
  - 다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 같음
  - 툼스톤 : 형제를 병합할 때 상품을 제거했음을 나타내기 위해 해당 버전 번호에 남기는 표시

- 버전 벡터
  - 다중 복제본 -> 키당 버전 번호, 복제본당 버전 번호
  - 버전 벡터 : 모든 복제본의 버전 번호 모음
  