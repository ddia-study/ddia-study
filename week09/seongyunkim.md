# 08. 분산 시스템의 골칫거리

- 분산  시스템: 공유 메모리가 없고 신뢰할 수 없는 네트워크를 통해 메세지를 보낼 수 있을 뿐 부분 장애, 신뢰성 없는 시계, 프로세스 중단 가능 ⇒ 각 노드는 어떤 것도 **확실히 알지 못함**
- 원격 노드가 응답하지 않으면 노드가 어떤 상태인지 알 수 없음 (네트워크 문제인지 노드 문제인지  구별 불가)
- 시스템에서 어떤 것이 진실이고 거짓인가? 어떻게 진실을 확신할 수 있나?
- 시스템 모델에 대해 정한 가정을 명시, 가정을 만족시키는 방식으로 시스템을 설계하는 방식으로 기반 시스템 모델이 매우 적은 보장만 제공하더라도 신뢰성 있는 동작을 달성할 수 있음

## 진실은 다수결로 결정된다

- 시나리오
    - 비대칭적인 결함이 있는 네트워크:  들어오는 메세지는 모두 받을 수 있지만 밖으로 나가는 메세지는 모두 유실됨, 한 쪽 연결이 끊긴 노드는 네트워크 결함을 깨달을 수 있지만 아무 일도 할 수 없음
    - stop-the-world 경험 노드: GC로 노드가 아무 처리를 하지 못해 죽었다고 선언하지만 GC가 끝나고 노드의 스레드는 실행 재개, GC 노드는 자신이 죽었다고 선언된 사실을 알 지 못함
    - 교훈: 노드 상황에 대한 판단을 반디스 믿을 수 있는 것이 아니다 ⇒ 정족수(투표)에 의존

### 리더와 잠금

- 시스템에서 오직 하나의 뭔가가 필요한 경우
    - 스플릿 브레인을 피하기 위해서 한 노드만 파티션의 리더가 될 수 있음
    - 동시 쓰기, 오염을 방지하기 위해 하나의 트랜잭션만 자원에 대한 잠금을 획득할 수 있음
    - 한 명의 사용자만 특정한 사용자명으로 등록할 수 있음 (중복 X)
- 분산 시스템에서는 어떤 노드가 리더였더라도 시간이 흐르고 다른 노드가 리더가 죽었다고 선언하면 다른 리더가 이미 선출됐을 수도 있음
    - 이런 상황에서 기존 노드가 리더처럼 행동하면 문제를 유발함
    - 그림 8-4: 클라이언트 1은 임차권이 만료됐지만 GC가 끝나고 유효하다고 생각해 저장소 파일을 오염

### 펜싱(fencing) 토큰

- “선택된 자"라고 잘못 믿고 있는 노드가 나머지 시스템을 방해할 수 없도록 ⇒ 펜싱(fencing)
- 잠금 서비스(ex. 주키퍼)가 임차권을 승인할 때마다 증가하는 펜싱 토큰을 반환 ⇒ 증가하는 순서에 맞는 쓰기만 허용하도록

## 비잔팀 결함

- 펜싱 토큰: 노드가 고의로 시스템 보장을 무너뜨리려 가짜 펜싱 토큰을 보내는 경우(거짓말) 막지 못함
- 비잔팀 결함: 노드가 실제로 받지 않은 메세지를 받았다고 주장 ⇒ 어떻게 신뢰할 수 없는 환경에서 합의에 도달할 것인가 (비잔팀 장군 문제)
- 책에서 살펴보는 시스템은 데이터센터에서 모든 노드를 제어, 비잔팀 결함이 없다고 가정
- 웹 애플리케이션은 Input validation, sanitization (SQL Injection 방어) 등을 통해 클라이언트의 악의적 행동을 예상하고 방어 필요
- 비잔팀 내결함성은 중앙 권한이 없는 P2P 네트워크에 적합

### 약한 형태의 거짓말

- 예시: 하드웨어 문제, 소프트웨어 버그, 잘못된 설정으로 인한 유효하지 않은 메세지
- 약한 형태 거짓말 보호 매커니즘 ⇒ 완전한 비잔팀 내결함성은 아니지만 더 나은 신뢰성
    - 오염된 네트워크 패킷으로부터 보호하기 위해 애플리케이션 수준의 체크섬
    - 사용자 입력 살균: 값의 범위, 문자열 크기 등 입력값 Validation
    - NTP 클라이언트가 여러 서버 주소를 설정해 이상치를 동기화 대상에서 제거

## 시스템 모델의 현실

- 시스템 발생 결함 종류 (시스템 모델: 알고리즘이 가정하는 것) 정형화 필요
- 타이밍 시스템 모델
    - 동기식 모델: 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정 (고정된 상한치를 초과하지 않을 것임) ⇒ 기약없는 지연, 중단 발생하기 때문에 현실적인 모델 X
    - 부분 동기식 모델: 대부분의 시간에는 동기식 시스템처럼 동작. 때때로 네트워크 지연, 프로세스 중단, 시계 오차가 한계치 초과 ⇒ 현실적인 모델
    - 비동기식 모델: 어떤 가정도 할 수 없음. 시계가 없다면 타임아웃도 사용하지 못함 (매우 제한적인 모델)
- 노드 시스템 모델
    - crash-stop 결함: 노드가 응답하기를 멈추면 그 노드는 영원히 사용할 수 없음을 가정
    - crash-recovery 결함: 노드가 응답하기를 멈추면 어느 순간에는 죽을 수 있지만 언젠가 다시 응답하기 시작할 것이라고 가정 ⇒ 현실적인 모델
    - 비잔팀 결함: 노드는 다른 노드를 속이거나 기만할 수 있음을 가정

### 알고리즘의 정확성

- 정확하다는 게 어떤 뜻인지 정의하고 싶은 분산 시스템의 속성 ⇒ 속성을 만족시키면 해당 시스템 모델이 정확
    - 유일성: 펜싱 토큰 요청이 같은 값을 반환하지 않음
    - 단조 일련번호: 점점 증가하는 토큰 번호
    - 가용성: 펜싱 토큰을 요청하고 죽지 않는 노드는 결국 응답을 받음

### 안전성과 활동성

- 안정성: 나쁜 일은 일어나지 않는다 (ex. 유일성, 단조 일련번호)
    - 위반되면 해당 속성이 깨진 시점을 가리킬 수 있음, 위반 후에는 위반을 취소할 수 없음
- 활동성: 좋은 일을 결국(eventually) 일어난다 (ex. 가용성)
    - 위반되면 시점을 특정할 수 없지만 미래에 그 속성을 만족시킬 수 있다는 희망이 있음
- 분산 시스템
    - 안정성 속성은 항상 만족되기를 요구: 모든 노드가 죽거나 네트워크 전체에 장애가 생겨도 알고리즘은 잘못된 결과를 반환하지 않음
    - 활동성 속성은 경고 허용(?): 얼마간의 네트워크 끊김이 있다면 복구되기를 요구
