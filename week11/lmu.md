## 분산 트랜잭션과 합의
- 합의의 목적 : 여러 노드들이 동의하는 것.
- 합의의 필요 예시:
  - 리더 선출, 원자적 커밋
- 합의 불가능성: FLP 결과(어떤 노드가 죽을 위험이 있다면 항상 합의를 할 수 있다는 보장이 되는 알고리즘은 없다.)

### 원자적 커밋
- 트랜잭션의 결과 : 커밋 성공, 어보트

#### 단일 노드에서 분산 원자적 커밋으로
- 트랜잭션에 여러 노드가 관여하게 되면 노드마다 성공 실패 여부가 달라져 원자성을 위반할 수 있다.
- 원자성을 위반하는 예시:
  - 어떤 노드들은 제약 조건 위반이나 충돌을 감지해서 어보트가 필요하게 하지만 다른 노드들은 성공적으로 커밋될 수 있다.
  - 어떤 커밋 요청은 네트워크에서 손실되어 타임아웃 때문에 결국 어보트되지만 다른 커밋 요청은 전달될 수 있다.
  - 어떤 노드는 커밋 레코드가 완전히 쓰여지기 전에 죽어서 복구할 때 롤백되지만 다른 노드는 성공적으로 커밋될 수 있다.

- 보상 트랜잭션(compensating transaction) : 커밋된 트랜잭션을 취소하고 싶을때 추가적으로 사용하는 트랜잭션, 보통 어플리케이션 레벨의 문제

#### 2단계 커밋 소개
- XA 트랜잭션
- 코디네이터(coordinator), 트랜잭션 관리자 : 주로, 트랜잭션을 요청하는 어플리케이션 프로세스 내에서 라이브러리 형태로 구현, 또는 분리된 프로세스나 서비스로 구현(JOTM, BTM, MSDTC, Narayana)
- 참여자(participant) : 트랜잭션에 관여하는 데이터베이스 노드
- 2PC 단계:
  - 모든 참여자가 커밋할 준비가 됐다는 뜻으로 "네"로 응답하면, 코디네이터는 2단계에서 커밋 요청을 보내고 커밋이 실제로 일어난다.
  - 참여자 중 누구라도 아니오로 응답하면 코디네이터는 2단계에서 모든 노드에 어보트 요청을 보낸다.

#### 약속에 관한 시스템
- 커밋 포인트 : 커밋에 관해 모든 준비 요청에 대해 응답을 받았을 때 트랜잭션이 커밋할지 어보트 할것인지 최종적 결정을 하고 이를 디스크의 트랜잭션 로그에 기록한다. 이를 커밋 포인트라고 한다.
- 모든 참여자는 답변을 하였을때 그에 관해 보장해야한다.:
  - 예를 들어, 커밋 가능하다 라고 답변하면 반드시 커밋 요청이 들어왔을때 커밋해야한다.

#### 코디네이터 장애
- 2PC 과정 중에 코디네이터의 네트워크 장애와 같은 문제가 발생하였을때 트랜잭션 처리는 중간에 멈추게 된다.
- 답변은 하였으나, 커밋포인트가 생성되지 않았을 경우 그 트랜잭션을 의심스럽다(in doubt) 또는 불확실하다(uncertain)이라고 한다.
- 이 상태에서는 코디네이터가 복구되는 것을 기다리는 것 이외에는 아무것도 할수 없다. :
  - 따라서 2PC를 blocking atomic commit protocol 이라고 부른다.
  - 이런 블로킹을 방지하고자 3PC가 제안되었으나 일반적으로 실용적이지 못하며, 원자성을 보장하지 못한다.
  - 근본적으로 논블로킹 원자적 커밋은 완벽한 장애 감지기가 존재해야하지만, 네트워크 장애 환경에서는 타임아웃 이외에 선택지가 없다.

### 현실의 분산 트랜잭션
- 분산 트랜잭션 구현은 일반적으로 무겁다.:
  - MySQL의 경우 분산 트랜잭션은 단일 트랜잭션보다 10배 이상 느리다고 보고된다.

- 분산 트랜잭션의 구분:
  - 데이터베이스 내부 분산 트랜잭션: 데이터베이스 노드 사이에 내부 트랜잭션
  - 이종 분산 트랜잭션 : 서로 다른 기술을 사용하여 트랜잭션을 하는 것

#### 정확히 한번 메시지 처리
- 결과적으로 정확히 한번 처리되도록 보장하는 것
- 메시지와 그 처리 과정의 부수효과를 원자적으로 커밋해야한다.

#### XA 트랜잭션
- X/Open XA(eXtended Architecture) : 이종 기술에 걸친 2단계 커밋을 구현하는 표준
- 구현은 표준으로 정의되지 않았지만, 일반적으로 어플리케이션과 같은 프로세스에 로딩되는 라이브러리 내부에 코디네이터를 넣는다.

#### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제
- 코디네이터가 죽어서(코디네이터를 포함하는 어플리케이션이 죽어서) 데이터베이스가 트랜잭션을 의심스러운 상태로 계속 유지하고 있으면 영구적으로 또는 관리자가 수동적으로 해결하기 전까지 남게된다.

#### 코디네이터 장애에서 복구하기
- orphaned 트랜잭션을 어떻게 처리할 수 있을까?
  - 데이터베이스를 재부팅하더라도 살아남는다.
  - 오로지 관리자가 수동으로 제거해줘야 한다.
- 따라서 논리적인 알고리즘에 의해서가 아닌 경험적인(heuristic decision) 결정을 구현해 비상 탈출구를 만든다.
  - 하지만 이는 원자성을 깰 수 있다는 불안이 있다.

### 분산 트랜잭션의 제약
- 코디네이터가 복제되지 않고 단일 장비에서만 실행되면 전체 시스템의 단일 장애점이 된다.
- 여러 서버 사이드 어플리케이션은 데이터베이스에 상태를 저장하여 의존적이다. 하지만 많은 경우에 코디네이터는 서버 어플리케이션의 일부가 되고 이는 어플리케이션의 stateless를 위반한다.
- XA가 표준화된 프로토콜로서 동작하고 이는 SSI(직렬성 스탭숏 격리)와 함께 동작하지 않는다.
- 모든 참여자가 동의 해야하기 때문에 하나의 참여자라도 고장이 나게 되면 장애를 증폭시켜 내결함성을 떨어뜨린다.

### 내결함성을 지닌 합의
- 균일한 동의 : 어떤 노드도 다르게 결정하지 않는다.
- 무결성 : 어떤 노드도 결정을 바꾸지 않는다.
- 유효성 : 한 노드가 값을 결정한다면, 이는 누군가 제안한 것이다.
- 종료 : 죽지 않은 모든 노드는 결구 어떤 값을 결정한다.

#### 합의 알고리즘과 전체 순서 브로드캐스트
- 뷰스탬프 복제(Viewstamped Replication, VSR)
- 팍소스(Paxos)
- 라프트(Raft)
- 잽(Zab)

- 위 알고리즘은 내결함성을 위한 속성들을 구현하는 것이 아닌 전체 순서 브로드캐스트를 만든다.
- 전체 순서 브로드캐스트는 반복된 횟수의 합의와 동일하다.

#### 단일 리더 복제와 합의
- 기존 리더에 장애가 나면 팔로워 하나를 리더로 승격 시켜 자동 리더 선출과 장애 복구를 수행한다.
- 스플릿 브레인:
  - 고장 난줄 알았던 리더가 살아 돌아와 서로가 리더라고 주장하며 시스템이 망가지는 것

#### 에포크 번호 붙이기와 정족수
- epoch number, ballot number, view number, term number : 각 합의 알고리즘에서 사용되는 용어이며, 동일한 숫자 내에 리더는 단일이라는 것을 보장한다.
- 무언가를 결정할때 두번의 투표를 한다. 한번은 리더를 선출하기 위해 두번째는 리더의 제안에 투표하기 위해서이며 이 두번의 투표에서는 정족수가 겹쳐야 한다.
  - 리더 선출에 참여한 노드가 있어야지 제안에 대한 투표를 할 수 있다.

#### 합의의 제약
- 합의 시스템은 엄격한 과반수가 동작하기를 원하고 이는 적어도 3대를 필요로 하며, 장애에 대응하기 위해서는 더 많은 수의 정족수가 필요하다.
- 대부분의 합의 알고리즘은 투표에 참여하는 노드 집합이 고정 되어 있다고 가정한다.:
  - 동적으로 이 집합이 변화하는 것을 동적 맴버십(dynamic membership) 확장이라 부르며 이는 더 복잡한 알고리즘을 요구한다.
- 장애 노드 감지를 타임아웃에 의존한다.:
  - 다른 대안이 없다.
  - 합의 알고리즘은 네트워크 문제에 민감하며 신뢰성이 없는 네트워크에서 설계하는 것은 아직도 연구되고 있다.

### 맴버십과 코디네이션 서비스
- zookeeper, etcd
- 완전히 메모리 안에 들어올 수 잇는 작은 양의 데이터를 보관하도록 설계되었다.
- 내결함성 문제를 해결하기 위해서 사용한다.

- zookeeper의 특이한 기능:
  - 선형성 원자적 연산 : 이건 다른 코디네이션 서비스에도 존재
  - 연산의 전체 순서화 : 펜싱토큰을 사용
  - 장애 감지 : 하트비트를 주기적으로 교환하고 세션 타임아웃 될 경우 장애로 판단
  - 변경 알림 : 알림을 구독하므로써 주기적 폴링을 방지할 수 있음

#### 작업을 노드에 할당하기
- 주키퍼/처비 모델이 적합한 예시:
  - 리더 또는 main component 선택할 때
  - 파티셔닝된 자원에서 어떤 파티션을 어떤 노드에 할당해야할지

#### 서비스 찾기
- 서비스 찾기 자체는 합이가 필요 없지만 리더 선출에는 합의가 필요하다.

#### 맴버십 서비스
- 클러스터에 어떤 노드가 현재 살아 있는 맴버인지를 결정한다.
