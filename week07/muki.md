# 동시성 문제

[정리 주소]([https://blog.naver.com/blaxh1101/222707970750](https://blog.naver.com/blaxh1101/222707970750))

---

- 동시성 버그는 타이밍으로 인해 발견하기 어렵고 예측하거나 재현하기 어려움
- 데이터 베이스는 트랜잭션 격리를 통해 어플리케이션 개발자들에게 동시성 문제를 감춤(직렬성 처럼 보이게 함)

but, 직렬성 격리는 "**성능 Cost**"가 큼 따라서 어떤 이슈는 보호해주고 어떤이슈는 보호하지 않는 **완화된 격리 수준**을 유지한다.(P.233)

but2, 이런 방식은 이해하기 더 어렵고 버그를 유발할 수 있음 + 금전적 손실을 일으킴(고객의 데이터 오염)

이러한 완화된 격리 수준을 몇 가지 살펴보자.

---

## 완화된 격리 수준 - 커밋 후 읽기

커밋 후 읽기가 보장해주는 2가지

1. 데이터 베이스에서 읽을 때 커밋된 데이터만 보게 된다.(더티 읽기 없음)

2. 데이터 베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.(더티 쓰기 없음)

- 더티 읽기 방지
    
    트랜젝션에서 커밋되지 않은 데이터를 읽는 경우, 이를 막음
    
- 더티 읽기는 막는 것이 유용한 이유

1. 트랜잭션이 일부는 갱신된 값을 일부는 갱신되지 않은 값을 볼 수 있음

2. 트랜잭션이 어보트 되는 경우 데이터베이스에 결코 커밋되지 않을 데이터를 볼 수 있음

- 더티 쓰기 방지

두 트랜잭션이 동일한 객체를 동시에 갱신하려 하는 경우 나중에 쓴 내용이 앞의 내용을 덮어버림(한쪽의 내용이 무의미해짐)

따라서, 먼저 쓴 트랜잭션이 커밋이나 어보트 될 때까지 두번째 쓰기를 지연시킴

- 커밋 후 읽기 구현

로우 수준 잠금을 사용해 더티 쓰기를 방지, 오직 한 트랜잭션만 쓰거나 수정의 잠금을 보유

커밋이 완료된 후의 값들만 읽기를 통해 읽게 함(수정 전 값과 수정 후의 값만, 중간의 값은 X)

---

## 완화된 격리 수준 - 스냅숏 격리

커밋 후 읽기를 사용하더라도 동시성 문제는 아직 발생한다.

ex. A(500) -(100)-> B(500)로 송금한다 했을때 송금 중간에 조회를 해보면 A는 400 B는 500인 경우를 볼 수도 있다.

- 이러한 이상현상 **비반복 읽기, 읽기 스큐**라고 함

보통 이런 문제는 다시 읽으면 트랜잭션 종료가 돼서 정상적인 결과를 반환하지만 아래의 상황에서는 문제가 된다.

- 백업(일부는 데이터의 과거 버전, 일부는 현재 버전을 복제하면 영원히 다른 값을 가지게 됨)
- 분석 질의와 무결성 확인(큰 범위의 질의의 경우 역시 같음)
- 스탭숏 격리

각 트랜잭션은 데이터 베이스의 일관된 스냅숏으로부터 읽는다, 트랜잭션 시작 시에 데이터베이스에 커밋된 상태였던

데이터 봄

+) 오라클에서는 직렬성, Mysql에서는 반복 읽기 라고 부름

- 스냅숏 격리 구현

쓰는 트랜젝션은 쓰기 잠금을 통해 다른 트랜잭션의 진행을 차단, 읽을 때는 잠금 필요 없음

읽는 쪽에서 쓰는 쪽을 차단하지 않고 쓰는 쪽에서 읽는 쪽을 차단하지 않음

객체마다 커밋된 버전 여러개 유지(MVCC, multi-version concurrency control)

- 일관된 스냅숏을 보는 가시성 규칙

트랜잭션은 객체을 읽을 때 트랜잭션 ID를 사용해 볼 수 있는 것과 없는 것 결정

1. 트랜잭션 시작 시점에 진행 중인 트랜잭션 목록 만들고 해당 트랜잭션이 쓴 데이터 모두 무시

2. 어보트된 트랜잭션이 쓴 데이터 무시

3. 트랜잭션 ID가 더 큰 트랜잭션(현재 트랜잭션 이후의 트랜잭션)이 쓴 데이터 무시

4. 나머지 데이터 볼 수 있음

---

- 다른 트랜잭션들이 동시에 같은 객체에 쓰려고 할 때 발생할 수 있는 경쟁 조건을 막는 방법

## 갱실 손실 방지

갱신 트랜잭션이 동시에 도착하는 경우 전에 도착한 갱신 요청이 무시되는 경우 -> 갱신 손실

이를 막기 위해 다양한 해결책이 개발됐다.

1. 원자적 쓰기 연산

객체를 읽을 때 독점적인 잠금을 획득하여 구현, 객신이 적용될 때까지 다른 트랜잭션이 객체 접근X -> 커서 안정성

ex) compare-and-set

2. 명시적 잠금

어플리케이션에서 갱신할 객체를 명시적으로 잠금

3. 갱신 손실 자동 감지

위 2가지와 다르게 병렬 실행을 허용하고 관리자가 갱신 손실을 발견하면 어보트 시키고 read-modify-write 주기를 재시도하도록 강제하는 방법

- 충돌 해소와 복제
    
    복제가 적용된 데이터 베이스에서의 갱신 손실을 막는 것은 다른 차원의 문제이다.
    
    다중 리더 또는 리더 없는 복제의 경우에는 여러 개의 충돌된 버전(형제)를 생성하고 사후에 충돌을 해소, 병합하는 방식 채택
    
- 쓰기 스큐
    
    ex. 비상 대기조(최소 1명 필요)의 인원 2명이 서로가 있는 것을 확인하고 동시에 퇴근하는 경우
    
    ex2. 회의실이 비어있는 것을 보고 동시에 회의실 예약을 하게 되는 경우
    
    두 트랜잭션이 같은 객체를 읽어서 그중 일부를 갱신할 때 나타날 수 있음
    
- 쓰기 스큐를 유발하는 팬텀
    
    쓰기 스큐의 예는 비슷한 패턴을 따른다.
    
    1. SELECT 질의가 어떤 조건에 부합하는 로우를 검색해서 요구사항을 만족하는지 확인한다.
    
    2. 첫 번째 질의의 결과에 따라 어플리케이션 코드가 어떻게 진행할지 결정한다.
    
    3. 어플리케이션이 계속 처리하기를 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋한다. 이때 쓰기의 효과로 2단계를 결정한 조건이 바뀐다.
    
    이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 **팬텀**이라고 한다.
    
- 충돌 구체화
    
    데이터베이스에 잠금 객체를 추가하는 방식.
    
    팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환
    
    ex. 회의실 예약의 경우 시간 슬롯과 회의실에 대한 테이블을 추가로 만들어 잠그는 방식
    

+) 구체화하는 방법은 알아내기 어렵고 오류 발생이 쉬움 -> 최후의 수단으로 생각 or 직렬성 격리 수준 사용

---

---

## 직렬성

여러 트랜잭션이 병렬로 실행되더라도 직렬로 실행될 때와 같도록 보장.

데이터 베이스가 모든 경쟁 조건을 막아준다.

- 직렬성을 제공하는 데이터베이스의 세 가지 기법

1. 실제적인 트랜잭션 순차적으로 실행하기

2. 2단계 잠금

3. 낙관적 동시성 제어

1. 실제적인 직렬 실행
    
    하나씩 직렬로 단일 스레드에서 실행
    
    Q. 단일 스레드 루프에서 트랜잭션 수행이 가능한 이유?
    
    1. 램 가격이 저렴해져서 데이터셋 전체를 메모리에 유지 가능
    
    2. OLTP 트랜잭션이 보통 짧고 읽기와 쓰기 개수가 작음, 오래 걸리는 질의는 보통 읽기
    
    레디스, 데이토믹, ...
    

2. 2단계 잠금

쓰기를 실행하는 트랜잭션이 없는 객체는 여러 트랜잭션에서 동시에 읽을 수 있다. 그러나 어떤 객체에 쓰려고 하면 독점적인 접근이 필요하다.

- 2단계 잠금 구현
    - 공유 모드, 독점 모드 사용
- 서술 잠금
    - 특정 객체에 속하지 않고 검색 조건에 부합하는 모든 객체 잠금
- 색인 범위 잠금
    - 서술 잠금이 검색 조건이 많은 경우에 적합하지 않음 -> 색인 범위 잠금 사용
    - 다음 키 잠금이라고도 함
    - 색인 항목에 공유 잠금을 잡아서 사용 -> 색인 항목이 없다면 테이블 전체에 잠금

3. 직렬성 스냅숏 격리(SSI, Serializable Snapshot isolation)

완전한 직렬성을 제공 + 스냅숏 격리에 비해 약간의 성능 손해

스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘 추가

- 비관적 동시성 제어 vs 낙관적 동시성 제어
    - 2단계 <- 비관적 동시성 제어 = 안전해 질때까지 기다림, 상호 배제와 유사
    - 직렬 실행 <- 극단적으로 비관적
    - 스냅숏 격리 <- 낙과적 동시성 제어= 위험한 상황이 발생할 가능성이 있음
    - 낙관적 트랜잭션의 경우 경쟁이 심하면 어보트 시켜야할 트랜잭션의 비율이 높아짐 -> 성능 저하
    - SSI는 스넵숏 격리 기반
- 데이터 베이스가 질의 결과가 바뀌었는지 알 수 있는지?
    - 오래된 MVCC 읽기 감지하기
        - 다른 트랜잭션의 쓰기를 무시하는 경우 추적
        - 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지
    - 과거의 읽기에 영향을 미치는 쓰기 감지
        - 데이터를 읽은 후 다른 트랜잭션에서 해당 데이터를 변경할 때
        - 쓸 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인 + 읽는 쪽이 확인할때까지 차단X
        - 지뢰선(tripwire) 처럼 읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려주기만 함
- 직렬성 스냅숏 격리의 성능
    - 트레이드 오프 : 트랜잭션의 읽기 쓰기를 추적하는 세밀함의 정도(기록 오버헤드 vs 많은 트랜잭션 어보트)
    - 질의 지연 시간 예측이 쉽고 변동이 적음 + 읽기 작업 부하가 심한 경우 매력적
    - 어보트 비율이 SSI의 성능에 큰 영향

정리

- 트랜잭션은 애플리케이션이 어떤 동시성 문제와 어떤 종류의 하드웨어&소프트웨어 결함이 존재하지 않는 것 처럼 동작할 수 있게 도와주는 추상층
- 오류 -> 트랜잭션 어포트 = 어플리케이션은 재시도

---

Q. 여기서의 성능 비용(Cost)에는 무엇이 있을까요?

다중 트랜젝션이 수행될때 직렬하게 보이기 위해 한 트랜젝션이 끝나는 동안 기다리는 낭비가 발생

- 스냅숏 격리