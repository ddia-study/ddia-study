# 07. 트랜잭션

## 완화된 격리 수준

동시성 문제: 두 트랜잭션이 같은 데이터를 변경하거나 동시에 변경한 데이터를 읽을 때 발생 (타이밍에 운이 없을 때만 발생할 수 있어 재현이 어려움)

직렬성(Serializable) 격리: 동시성 없이 한 번에 트랜잭션 하나만 실행 (동일한 결과 보장) → 성능 비용, 완화된 격리 수준 (비직렬성)

- 커밋 후 읽기 (Read Committed)
    - Dirty Read 방지: 읽을 때 커밋된 데이터만 볼 수 있음
        - 트랜잭션 커밋 후에야 다른 트랜잭션에 보임
        - 부분적으로 갱신된 상태의 데이터가 보이는 것을 방지
        - 어보트되어 롤백될 데이터가 보이는 것을 방지
    - Dirty Write 방지: 쓸 때 커밋된 데이터만 덮어 씀
        - 먼저 쓴 트랜잭션 커밋 될 때 까지 두 번째 쓰기를 지연
        - 서로 다른 트랜잭션의 쓰기 결과가 섞여 저장되는 것을 방지
    - 구현
        - 로우 수준 잠금을 사용해 더티 쓰기 방지
            - 특정 로우를 변경하고 싶다면 로우에 대한 잠금을 획득해야
            - 다른 트랙잭션이 동일한 로우에 쓰기를 원한다면 이전 트랜잭션이 커밋된 후 잠금을 얻어 진행
        - 로우 수준 잠금을 더티 읽기를 방지하기 위해 사용한다면, 운용성이 나쁨 (읽기 트랜잭션이 쓰기 트랜잭션 완료를 기다려야)
            - 모든 객체에 과거 커밋 값과 새 값을 모두 기억
- 스냅숏 격리와 반복 읽기 (Repetable Read)
    - Read Commiteed의 문제: Non-Repeatable Read
        - 한 트랜잭션에서 로우가 두 번 검색되고 두 쿼리의 결과가 다름
    - 스냅숏 격리
        - 트랜잭션 시작할 때 커밋 상태의 데이터만 읽도록
        - 백업, 분석 질의 등 오랜 시간동안 읽기만 하는 질의에 유용
    - 구현
        - 읽는 쪽에서는 쓰는 쪽을 차단하지 않고 쓰는 쪽에서는 읽는 쪽을 차단하지 않음
        - MVCC: 트랜잭션에서 서로 다른 시점의 데이터 상태를 보기 위해, 로우의 여러 버전을 함께 유지
            - 트랜잭션이 시작하면 증가하는 트랜잭션 ID 발급
            - created_by: 삽입 트랜잭션 ID
            - deleted_by: 삭제 트랜잭션 ID
            - 갱신은 내부적으로 삭제와 생성으로 변환
    - 일관된 스냅숏을 보는 가시성 규칙
        - 트랜잭션 시작 시 진행 중인 트랜잭션 목록을 만들고 이 트랜잭션이 쓴 데이터는 무시
        - 트랜잭션 ID가 큰 (뒤늦게 시작한) 트랜잭션이 쓴 데이터는 무시
    - MVCC에서의 인덱스
        - TBU
- 갱신 손실 방지

완화된 격리 수준: 동시 실행 쓰기 작업이 있을 때 읽기 전용 트랜잭션이 무엇을 볼 수 있는가

갱신 손실 방지: 두 트랜잭션이 동시에 쓰기 (카운터 예시, read-modify-write)

- 원자적 쓰기 연산
    - UPDATE 연산: 애플리케이션에서의 read-modify-write 방지
    - 객체를 읽을 때 독점적(exclusive) 잠금을 획득, 갱신 적용 될 때까지 다른 트랜잭션에서 읽지 못함 (참고: [Lock의 종류](https://jaeseongdev.github.io/development/2021/06/16/Lock%EC%9D%98-%EC%A2%85%EB%A5%98-(Shared-Lock,-Exclusive-Lock,-Record-Lock,-Gap-Lock,-Next-key-Lock)/))
- 명시적인 잠금
    - 원자적 연산으로 불충분해 애플리케이션의 read-modify-write가 완료될 때 까지 잠금 강제
- 갱신 손실 자동 감지
    - 트랜잭션 병렬 실행 허용, 트랜잭션 관리자가 갱신 손실을 감지하면 어보트시키고 read-modify-write 재시도
- Compare and set
    - 마지막 값을 읽은 후 변경 되지 않았을 때만 갱신을 허용, 일치하지 않으면 갱신을 반영하지 않고 read-modify-write 재시도
- 충돌 해소와 복제
    - 서로 다른 노드에서 동시 변경 가능 ⇒ 비동기식 복제가 허용되므로 잠금, compare-and-set 사용 불가
    - 충돌 버전 생성을 허용하고 애플리케이션 코드, 특별한 데이터 구조를 사용해 충돌 병합
- 쓰기 스큐와 팬텀
    - 쓰기 스큐: 두 트랜잭션이 서로 다른 객체를 갱신할 때 발생 (더티 쓰기와 갱신 손실은 동일한 객체를 갱신)
        - 원자적 쓰기 연산, 갱신 손실 자동 감지, 제약 조건 사용 불가
        - Serializable 격리 수준 또는 명시적 잠금 필요
    - 쓰기 스큐를 유발하는 팬텀
        - SELECT 질의에서 요구사항 만족 확인
        - SELECT 질의 결과에 따라 애플리케이션에서 계속 진행 여부 결정
        - 계속 진행하기로 결정했다면 INSERT, UPDATE, DELETE 트랜잭션이 커밋되고 전제 조건(질의 결과)이 바뀜
        - 팬텀: 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과
    - 충돌 구체화
        - 잠글 수 있는 객체가 없는 팬텀의 문제를 해결하기 위해 미리 잠금 객체를 생성하는 방식
        - 충돌 구체화 방법이 복잡, 동시성 제어 매커니즘이 애플리케이션 데이터 모델로 전파 ⇒ 대부분 Serializable 격리 수준 선호

## 직렬성

여러 트랜잭션이 병렬로 실행되도 직렬로 실행될 때와 같은 실행 결과 보장 (가장 강력한 격리 수준)

- 실제적인 직렬 실행
    - 한 번에 트랜잭션 하나만 직렬로 단일 스레드에서 실행
    - 장점: 잠금 코디네이션 오버헤드를 피해 복수 스레드보다 성능이 좋을 때도 있음
    - 단점: 처리량은 CPU 코어 하나로 제한
    - 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
        - 단일 스레드에서는 다중 구문 트랜잭션을 허용하지 않음
        - 대신, 애플리케이션은 트랜잭션 코드 전체를 스토어드 프로시저 형태로 미리 제출
        - 단점
            - DB에서 실행되는 코드는 디버깅, 버전 관리, 배포, 테스트 등이 어려움
            - 여러 애플리케이션에서 DB를 공유하기 때문에 성능에 민감
    - 파티셔닝
        - 단일 스레드로 단일 CPU 코어 속도로 성능이 제한 ⇒ 여러 CPU로 확장하기 위해 파티셔닝 가능
        - 각 트랜잭션이 단일 파티션 내에서만 읽고 쓸 때 좋음 (여러 파티션에 트랜잭션이 접근한다면 각 파티션에 걸쳐 잠금을 획득해야 ⇒ 오버헤드)
    - 요약
        - 모든 트랜잭션은 작고 빨라야 (느린 트랜잭션 하나가 전체를 지연시킬 수 있음)
        - 활성화된 데이터셋이 모두 메모리에 적재될 수 있어야 (단일 스레드 트랜잭션이 디스크에 접근한다면 시스템이 느려짐)
        - 쓰기 처리량이 단일 CPU 코어에서 처리 가능한 정도로 낮아야 (제약이 많은 파티셔닝을 피하기 위해서)
- 2단계 잠금 (2 Phase Lock)
    - 쓰기 트랜잭션은 다른 읽기/쓰기 트랜잭션이 진행못하게 막음
    - 읽기 트랜잭션은 다른 쓰기 트랜잭션이 진행못하게 막음
    - 구현
        - 객체를 읽을 때 공유 모드 잠금 획득 필요. 동시에 여러 트랜잭션이 공유 모드 획득은 허용. 그러나 이미 독점 모드 잠금을 획득한 트랜잭션이 있다면 완료될 때 까지 대기 필요
        - 객체를 쓸 때 독점 모드 잠금 획득 필요. 다른 어떤 트랜잭션도 공유, 독점 모드 잠금을 동시에 획득할 수 없고 대기 필요
        - 트랜잭션이 종료될 때 까지 잠금을 가지고 있어야 (1단계: 트랜직션 시작 시 잠금 획득, 2단계: 트랜잭션 종료 시 잠금 해제)
        - 교착 상태가 빈번하게 발생 (교착 상태 감지 시 하나 어보트 후 재시도)
    - 성능: 잠금 획득, 해제 오버헤드 + 동시성 악화 ⇒ 나쁜 (불안정한) 성능
    - 서술 잠금: 공유/독점 잠금과 비슷, 그러나 특정 객체가 아닌 검색 조건에 부합하는 모든 객체에
    - 색인 범위 잠금: 서술 잠금은 근사 버전 (검색 조건 색인을 기준으로 더 넓은 범위의 객체를 잠금)
- 직렬성 스냅숏 격리: 완전한 직렬성 + 스탭숏 격리에  비해 약간의 성능 저하
    - 비관적 vs 낙관적 동시성 제어
        - 비관적 동시성 제어: 트랜잭션이 객체를 잠금으로 표시하면 안전해질 때 까지 기다림 (2단계 잠금)
        - 낙관적 동시성  제어: 트랜잭션이 커밋되기를 원할 때, 격리가 위반됐는지 확인. 위반됐다면 어보트하고 재시도 (직렬성 스냅숏 격리)
            - 경쟁이 심하면 어보트 트랜잭션이 많아져 성능 저하 (경쟁이 크지 않을 때 유리)
            - 직렬성 스냅숏 격리: 스냅숏 격리 위에 쓰기 작업 사이 충돌을 감지, 어보트 트랜잭션을 결정
    - 쓰기 스큐를 막기 위해 질의 전제의 변경을 알 수 있는지 어떻게 알 수 있는가?
        - 오래된 MVCC 읽기 감지
            - MVCC 가시성 규칙에 따라 다른 트랜잭션 쓰기를 무시해 전제가 바뀌는 경우 추적
            - 트랜잭션이 커밋할 때 무시된 쓰기 중 커밋이 있다면 어보트 필요
        - 과거 읽기에 영향을 미치는 쓰기 감지
            - 데이터를 읽은 후 다른 트랜잭션에서 데이터를 변경하는지를 검색 조건 색인을 기준으로 추적
            - 트랜잭션이 읽은 데이터가 최신이 아님을 읽어줄 뿐 읽는 쪽에서 커밋될 때 까지 차단하지 않음
    - 성능
        - 트레이드 오프: 트랜잭션 추적의 세밀함 vs 어보트 트랜잭션 개수
        - 장점
            - 다른 트랜잭션이 잡고 있는 잠금을 기다릴 필요 없음 (like 스냅숏 격리, 질의 시간 예측이 쉬움)
            - 단일 CPU 코어 처리량에 제한 X
        - 제한
            - 오랫동안 읽는 트랙잭션은 충돌이 발생해 어보트 되기 쉬움 ⇒ 짧은 읽기 트랜잭션 유리
