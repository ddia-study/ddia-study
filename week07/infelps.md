## 완화된 격리 수준

- 두 트랜잭션이 동일한 데이터를 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있음
- 동시성 버그는 테스트로 발견하기 어려움, 특히 커다란 애플리케이션에서 어려움
- 트랜잭션 격리를 제공함으로써 개발자들에게 동시성 문제를 감추려고 하였음

- 직렬성 격리 : 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것과 동일한 결과가 나오도록 보장한다는 것을 의미
  - 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않음

- 완화된 격리 수준을 사용하는 시스템이 흔함
- 완화된 격리 수준, 경쟁 조건과 발생할 수 없는 경쟁 조건, 직렬성

### 커밋 후 읽기

- 가장 기본적인 수준의 트랜잭션 격리
- 데이터베이스에서 읽을 떄 커밋된 데이터만 보게 된다(더티 읽기가 없음)
- 데이터베이스에서 쓸 떄 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)

### 더티 읽기 방지

- 더티 읽기
  - 트랜잭션이 데이터베이스에 데이터를 썼지만 아직 커밋되거나 어보트되지 않았을 떄, 다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있는 경우

- 그림 7-4
- 더티 읽기를 막는 게 유용한 이유
  -  트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있음, 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스러우며 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수 있음
  -  트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백돼야 함, 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터, 결코 커밋되지 않을 데이터를 볼 수 있음

### 더티 쓰기 방지

- 더티 쓰기
  - 먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 갚을 덮어쓰는 것
  - 보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용함

- 더티 쓰기를 막음으로써 회피하는 동시성 문제
  - 트랜잭션들이 여러 객체를 갱신하면 더티 쓰기는 나쁜 결과를 유발할 수 있음, 그림 7-5, 커밋 후 읽기는 이런 사고를 막아줌
  - 커밋 후 읽기는 그림 7-1에 나온 두 번의 카운터 증가 사이에 발생하는 경쟁 조건은 막지 못함

### 커밋 후 읽기 구현

- 매우 널리 쓰이는 격리 수준, 오라클 11g, 포스트그레스큐엘, SQL 서버 2012, 멤SQL 등의 기본 설정
- 로우 수준 잠금을 사용해 더티 쓰기를 방지
  - 해당 객체에 대한 잠금을 획득해야 함
  - 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 함
  - 오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있음
  - 다른 트랜잭션에서 동일한 객체에 쓰기를 원한다면 첫 번째 트랜잭션이 커밋되거나 어보트된 후에야 잠금을 얻어 실행할 수 있음

- 동일한 잠금을 사용
  - 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있음
  - 읽기만 실행하는 트랜잭션들의 응답 시간에 해를 끼치며 운용성이 나쁨
  - 일부에서 발생한 지연이 애플리케이션의 완전히 다른 부분에 연쇄 효과를 미칠 수 있음

- 그림 7-4
  - 쓰여진 모든 객체에 대해 데이터베이스는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억함
  - 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 됨
  - 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 됨

### 스냅숏 격리와 반복 읽기

- 동시성 버그가 생길 수 있는 경우가 아직 많이 있음
- 그림 7-6
  - 비반복 읽기(nonrepeatable read), 읽기 스큐(read skew)

- 스큐 : 시간적인 이상 현상(timing anomaly)

- 일시적인 비일관성을 감내할 수 없는 경우
  - 백업 : 백업의 일부는 데이터의 과거 버전, 다른 부분은 새 버전을 갖고 있을 수 있음, 비일관성이 영속적이게 됨
  - 분석 질의와 무결성 확인 : 다른 시점의 데이터베이스의 일부를 보게 되면 불합리한 결과를 반환할 수 있음

- 스냅숏 격리 
  - 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽음
  - 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 봄, 특정 시점의 과거 데이터를 볼 뿐
  - 백업이나 분석처럼 실행하는 데 올 걸리며 읽기만 실행하는 질의에 요긴
  - 포스트그레스큐엘, 마이SQL, 오라클 SQL서버 등에서 지원

### 스냅숏 격리 구현

- 커밋 후 읽기 격리처럼 전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용함
- 쓰기를 실행하는 트랜잭션은 같은 객체에 쓰는 다른 트랜잭션의 진행을 차단할 수 있음
- 읽을 때에는 아무 잠금이 필요 없음
- **읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다**
- 다중 버전 동시성 제어(multi-version concurrency control, MVCC)
  - 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 함
  - 서로 다른 시점의 데이터베이스 상태를 봐야 할 수 있기 때문에
  - 커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용
  - 그림 7-7
  
### 일관된 스냅숏을 보는 가시성 규칙

- 면밀하게 가시성 규칙을 정의함으로써 일관된 스냅숏을 애플리케이션에게 제공할 수 있음
- 동작 방식
  - 데이테베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션 목록을 만듬, 이 트랜잭션들이 쓴 데이터는 모두 무시가 됨
  - 어보트된 트랜잭션이 쓴 데이터는 모두 무시
  - 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시

### 색인과 스냅숏 격리

- 포스트그레스큐엘 : 동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화
- 카우치DB, 데이토믹, LMDb : 추가 전용이며 쓸 떄 복사되는(append only/copy-on-write) 변종 사용
  
### 반복 읽기와 혼란스러운 이름

- 스냅숏 격리 : 오라클(직렬성), 포스트그레스큐엘 마이SQL(반복 읽기(repetable read))
  
### 갱신 손실 방지

- 갱신 손실(lost update)
  - 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있음
  - 나중에 쓴 것이 먼저 쓴 것을 때려눕힌다(clobber)
    - 카운터를 증가시키거나 계좌 잔고를 갱신한다
    - 복잡한 값을 지역적으로 변경한다
    - 두 명의 사용자가 동시에 같은 페이지를 편집한다

### 원자적 쓰기 연산

- UPDATE counters SET value = value +1 WHERE key = 'foo';
- 원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현
- 커서 안정성 : 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 함

### 명시적인 잠금

- 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때, 갱신할 객체를 명시적으로 잠그는 것
- 예제 7-1
- 올바르게 동작하게 하려면 애플리케이션 로직에 대해 신중하게 생각해야 함, 코드의 어딘가에 필요한 잠금을 추가하는 것을 잊어버려서 경쟁 조건을 유발하기 쉬움

### 갱신 손실 자동 감지

- 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제
- 스냅숏 격리와 결합해 효율적으로 수행할 수 있음
- 포스트그레스큐엘, 오라클, SQL 서버의 스냅숏 격리 수준은 갱신 손실이 발생하면 자동으로 발견하여 문제가 되는 트랜잭션을 어보트 함
  
### Compare and set

- 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것
- 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도해야 함
- 데이터베이스가 WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 갱신 손실을 막지 못할 수 있음

### 충돌 해소와 복제

- 여러 노드에 데이터의 복사본이 있어서 데이타가 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요함
- 잠금, compare and set을 기반으로 한 기법을 적용할 수 없음
- 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전(형제,sibling)을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합
- 원자적 연산은 복제 상황에서도 잘 동작함
- 최종 쓰기 승리는 갱신 손실이 발생하기 쉬움

### 쓰기 스큐와 팬텀

- 그림 7-8
- 두 트랜잭션 모두 커밋되고 호출 대기하는 의사가 한 명도 없게 됨

### 쓰기 스큐를 특징짓기

- 두 트랜잭션이 두 개의 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아닌 상황을 쓰기 스큐라고 함
- 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 나타날 수 있음
   - 여러 객체가 관련되므로 원자적 단일 객체 연산은 도움이 되지 않음
   - 일부 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지고 도움이 되지 않음
   - 어떤 데이터베이스에서는 제약 조건을 설정할 수 있음, 여러 객체와 연관된 제약 조건이 필요함
   - 직렬성 격리 수준을 사용할 수 없다면, 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책

### 쓰기 스큐를 유발하는 팬텀

- 패턴
  - SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인함
  - 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 사용자에게 오류를 보고하고 중단할지 결정함
  - 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋함, 이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀜
- 팬텀 : 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과

### 충돌 구체화

- 충돌 구체화 : 인위적으로 데이터베이스에 잠금 객체를 추가하는 것
- 팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환
- 충돌을 구체화하는 방법은 알아내기 어렵고 오류가 발생하기 쉬움, 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 새어 나오는 것도 보기 좋지 않음
- 직렬성 격리 수준이 훨씬 더 선호됨

## 직렬성

- 격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없음
- 애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어려움
- 경쟁 조건을 감지하는데 도움이 되는 좋은 도구가 없음

- 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장
- 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아줌
- 트랜잭션을 순차적으로 실행하기, 2단계 잠금, 직렬성 스냅숏 격리

### 실제적인 직렬 실행

- 한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 됨
- 두 가지 발전
  - 램 가격이 저렴해져서 많은 사용 사례에서 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됨
  - 데이터베이스 설계자들은 OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달음, 오래 실행되는 분석 질의는 전형적으로 읽기 전용이라서 직렬 실행 루프 밖에서 일관된 스냅숏을 사용해 실행할 수 있음

### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기

- 데이터베이스의 초창기에는 데이터베이스 트랜잭션이 사용자 활동의 전체 흐름을 포함할 수 있게 하려는 의도가 있었음
  - 데이터베이스는 대부분 유휴 상태지만 잠재적으로 매우 많은 동시 실행 트랜잭션을 지원해야 함
  - 웹의 경우 트랜잭션이 동일한 HTTP 요청 내에서 커밋됨

- 클라이언트/서버 스타일로 실행돼 왔음
  - 애플리케이션과 데이터베이스 사이의 네트워크 통신에 많은 시간을 소비

- 단일 스레드에서 트랜잭션을 순차적으로 처리하는 시스템들은 상호작용하는 다중 구문 트랜잭션을 허용하지 않음
- 애플리케이션은 트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 제출해야 함
- 그림 7-9

### 스토어드 프로시저의 장단점

- 단점
  - 데이타베이스 벤더마다 제각각 스토어드 프로시저용 언어가 있음, 이 언어들은 매우 조잡하고 낡아 보이며 라이브러리 생태계가 빈약함
  - 데이터베이스에서 실행되는 코드는 관리하기 어려움
  - 데이터베이스는 애플리케이션 서버보다 훨씬 더 성능에 민감할 때가 많음, 잘못 작성된 코드가 애플리케이션 서버에 미치는 것보다 데이터베이스에 훨씬 더 곤란한 상황을 만들 수 있음

- 범용 프로그래밍 언어를 사용, Java, Groovy, Clojure, Lua
- 스토어드 프로시저가 있고 데이터가 메모리에 저장된다면 모든 트랜잭션을 단일 스레드에서 실행하는 게 현실성 있음
- I/O 대기가 필요 없고 다른 동시성 제어 메커니즘의 오버헤드를 회피하므로 단일 스레드로 좋은 처리량을 얻을 수 있음

### 파티셔닝

- 모든 트랜잭션을 순차적으로 실행하면 동시성 제어는 훨씬 간단해지지만 데이터베이스의 트랜잭션 처리량이 단일 장비에 있는 단일 CPU 코어의 속도로 제한됨
- 쓰기 처리량이 높은 애플리케이션에서는 심각한 병목이 될 수 있음
- 여러 CPU 코어와 여러 노드로 확장하기 위해 데이터를 파티셔닝할 수 있음
  - 여러 파티션에 접근해야 하는 트랜잭션이 있다면 데이터베이스가 해당 트랜잭션이 접근하는 모든 파티션에 걸쳐서 코디네이션을 해야함
  - 스토어드 프로시저는 모든 파티션에 걸쳐 잠금을 획득한 단계에서 실행되야 함
  - 여러 파티션에 걸친 트랜잭션은 추가적인 코디네이션 오버헤드가 있어 단일 파티션 트랜잭션보다 엄청나게 느림

### 직렬 실행 요약

- 트랜잭션 직렬 실행
  - 모든 트랜잭션은 작고 빨라야 함
  - 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한됨
  - 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 낮아야 함
  - 여러 파티션에 걸친 트랜잭션도 사용가능하지만 엄격한 제한이 있음

### 2단계 잠금(2PL)

- 쓰기를 실행하는 트랜잭션이 없는 객체는 여러 트랜잭션에서 동시에 읽을 수 있음
- 어떤 객체에 변경/삭제 하기 위해선 독점적인 접근이 필요함
- 쓰기 트랜잭션은 다른 쓰기 트랜잭션/읽기 트랜잭션을 못하게 막음
  
### 2단계 잠금 구현

- 잠금은 공유 모드나 독점 모드로 사용될 수 있음
  - 트랜잭션이 객체를 읽기 원한다면 먼저 공유 모드로 잠금을 획득해야 함
  - 트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 함
  - 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드
  - 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될 때까지 잠금을 갖고 있어야 함

- 교착 상태
  - 데이터베이스는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 트랜잭션 중 하나를 어보트 시킴

### 2단계 잠금의 성능

- 트랜잭션 처리량과 질의 응답 시간이 크게 나빠짐
- 동시성이 줄어듬
- 경쟁이 있다면 지연 시간이 아주 불안정하고 높은 백분위에서 매우 느릴 수 있음
- 교착 상태가 자주 발생함

### 서술 잠금

- 직렬성 격리를 쓰는 데이터베이스는 팬텀을 막아야 함
- 서술 잠금(predicate lock)
  - 공유/독점 잠금과 비슷하게 동작하지만 특정 객체에 속하지 않고 어떤 검색 조건에 부합하는 모든 객체에 속함
  - 서술 잠금이 접근을 제한하는 방법
    - 트랜잭션 A가 어떤 조건에 부합하는 객체를 읽기 원한다면 질의의 조건에 대한 공유 모드 서술 잠금을 획득해야 함
    - 트랜잭션 A가 어떤 객체를 삽입, 갱신, 삭제하길 원한다면 먼저 기존 값이나 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 함
  - 서술 잠금은 데이터베이스에 아직 존재하지 않지만 미래에 추가될 수 있는 객체에도 적용할 수 있음
  - 2단계 잠금이 서술 잠금이 서술 잠금을 포함하면 데이터베이스에서 모든 형태의 쓰기 스큐와 다른 경쟁 조건을 막을 수 있어서 격리 수준이 직렬성 격리가 됨

### 색인 범위 잠금

- 서술 잠금은 잘 동작하지 않음
- 2PL을 지원하는 대부분의 데이터베이스는 실제로는 색위 범위 잠금(index-range locking)을 구현, 서술 잠금을 간략하게 근사한 것
- 더 많은 객체가 부합하도록 서술 조건을 간략화하는 것은 안전함
- 간략화한 검색 조건이 색인 중 하나에 붙고, 다른 트랜잭션이 삽입 갱신 삭제하길 원한다면 색인의 같은 부분을 갱신해야 함
- 팬텀과 쓰기 스큐로부터 보호해주는 효과를 낳음
- 서술 잠금보다 정밀하진 않지만 오버헤드가 훨씬 더 낮기 때문에 좋은 타협안이 됨

### 직렬성 스냅숏 격리

- 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있을 뿐임
- 오늘날 SSI는 단일 노드 데이터베이스와 분산 데이터베이스 모두에서 사용됨

### 비관적 동시성 제어 대 낙관적 동시성 제어

- 2단계 잠금은 이른바 비관적 동시성 제어 메커니즘
  - 뭔가 잘못된 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 함
  - 상호 배제와 비슷

- 각 트랜잭션이 실행되는 동안 전체 데이터베이스에 독점 잠금을 획득하는 것과 본질적으로 같음
- 개별 트랜잭션이 아주 빨리 실행되게 하여 잠금을 유지하는 시간을 줄이는 방법으로 비관주의를 보완
- 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법
  - 위험한 상황이 발생할 가능성이 있을 때 트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다는 뜻
  - 경쟁이 심하면 어보트시켜야 할 트랜잭션의 비율이 높아지므로 성능이 떨어짐
  - 예비 용량이 충분하고 트랜잭션 사이의 경쟁이 심하지 않으면 비관적 동시성 제어보다 성능이 좋은 경향이 있음

### 뒤처진 전체에 기반한 결정

- 스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과가 더 이상 최선이 아닐 수 있음
- 트랜잭션은 어떤 전제를 기반으로 어떤 동작을 함, 나중에는 데이터가 변경되어 그 전제가 더 이상 참이 아닐 수도 있음
- 안전하기 위해선, 데이터베이스는 질의 결과에 변화가 있으면 트랜잭션에서 실행하는 쓰기가 유효하지 않을 수 있다고 가정해야 함
- 트랜잭션에서 실행하는 질의와 쓰기 사이에는 인과적 의존성이 있을지 모름
- 데이터베이스는 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 그런 상황에서는 트랜잭션을 어보트시켜야 함
- 두 가지 상황
  - 오래된 MVCC 객체 버전을 읽었는지 감지하기
  - 과거의 읽기에 영향을 미치는 쓰기 감지하기

### 오래된 MVCC 읽기 감지하기

- 트랜잭션이 MVCC 데이터베이스의 일관된 스냅숏에서 읽으면 스냅숏 생성 시점에서 다른 트랜잭션이 썻지만 아직 커밋되지 않은 데이터는 무시
- 그림 7-10
  - 일관된 스냅숏에서 읽을 때는 무시됐던 쓰기가 지금은 영향이 있고 트랜잭션 43의 전제가 더이상 참이 아님

- 데이터베이스는 트랜잭션이 MVCC 가시성 규칙에 따라 다른 트랜잭션의 쓰기를 무시하는 경우를 추적해야 함
- 트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중 커밋된 것이 있는지 확인해야 함, 커밋된 게 있다면 트랜잭션은 어보트돼야 함
- SSI는 불필요한 어보트를 피해서, 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지

### 과거의 읽기에 영향을 미치는 쓰기 감지하기

- 그림 7-11
  - 데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경하는 경우
  - 트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야 함
  - 트랜잭션이 읽은 데이터가 더 이상 최신이 아니라고 트랜잭션에게 알려줄 뿐이다

### 직렬성 스냅숏 격리의 성능

- 데이터베이스가 각 트랜잭션 동작을 매우 상세하게 추적하면 어보트돼야 하는 트랜잭션을 정확히 판별할 수 있지만 기록 오버헤드가 심해질 수 있음
- 덜 상세하게 추적하면 빠르지만 진짜 필요한 것보다 지나치게 많은 트랜잭션이 어보트될 수 있음
- 2단계 잠금과 비교하여 직렬성 스냅숏 격리는 트랜잭션이 다른 트랜잭션들이 잡고 있는 잠금을 기다리느라 차단될 필요가 없다
- 쓰는 쪽은 읽는 쪽을 막지 않고 읽는 쪽도 쓰는 쪽을 막지 않음
- 순차 실행과 비교할 때 단일 CPU 코어의 처리량에 제한되지 않음