# 8장 - 분산 시스템의 골칫거리

- **결함과 부분장애**
    - 단일 컴퓨터에서 실행되는 소프트웨어
        - 하드웨어가 올바르게 동작하면 같은 결과를 낸다(결정적)
        - 하드웨어 문제시 시스템이 완전히 실패하는 결과
        - 완전하게 동작 or 전체 장애
    - 네트워크로 연결된 컴퓨터에서 실행되는 소프트웨어
        - 부분 장애(비결정적)
        - 어떨 때는 성공하지만 어떨 때는 실패
        
    
- **클라우드 컴퓨팅과 슈퍼컴퓨팅**
    - 대규모 컴퓨팅 시스템 구축 방법
        - 고성능 컴퓨팅 : 수천 개의 CPU를 가진 슈퍼컴퓨터가 일기예보나 분자 동력학처럼 계산 비용이 매우 높은 과학 계산 작업에 쓰임
        - 클라우드 컴퓨팅 : IP 네트워크로 연결된 사용 컴퓨터, 신축적/주문식 자원 할당, 계량 결제
        - 전통적인 기업형 데이터 센터는 두 극단의 중간 지점에 위치
    - 결함 처리 방법
        - 슈퍼 컴퓨터 : 가끔씩 계산 상태를 지속성 있는 저장소에 체크포인트로 저장 → 노드 장애시 노드 복구된 후 체크 포인트 부터 재시작
            - 부분 장애 → 전체 장애로 확대
        - 이 책에서 다루는 인터넷 서비스
            - 언제나 사용자에게 서비스를 제공해야하는 온라인
            - 여러 노드를 사용하기에 항상 고장나있는 상태
            - 장애가 난 노드를 감내 + 전체적으로는 계속 동작 → 유용한 특성
            - 지리적으로 분산된 배포를 할때 로컬 네트워크에 비해 느리고 신뢰성도 떨어짐
            
            → 부분 장애 고려해야 함
            
        

---

- **신뢰성이 없는 네트워크**
    - 비공유 시스템 : 네트워크로 연결되어 있고 다른 장비의 메모리나 디스크에 접근 불가
    - 특별한 하드웨어가 필요하지 않아 상대적으로 저렴
    - 인터넷과 데이터센터 내부 네트워크가 대부분 **비동기 패킷 네트워크 →** 비동기식으로 사용
    - 여러가지가 잘못될 수 있음
        - 요청이 손실됐다.(케이블 뽑는 경우)
        - 요청이 큐에서 대기하다 나중에 전송
        - 원격 노드에 장애가 생김
        - 원격 노드가 일시적으로 응답하기를 멈췄지만 나중에는 다시 응답하기 시작 가능
        - 요청을 처리했지만 응답이 네트워크에서 손실
        - 요청을 처리했지만 응답이 지연되다가 나중에 전송될 수 있음
        
        → 응답을 받지 못했으면 이유를 아는 것이 불가능 → **타임아웃**
        
    
    - 현실의 네트워크 결함
        - 아직 신뢰성 있는 네트워크 만드는 방법 성공 X
        - 결함이 일어날 수도 있나 → 처리할 수 있어야 한다. → 결함을 견뎌내도록까진?
        
        +) 네트워크 분단 : 네트워크 결함 때문에 네트워크 일부가 다른 쪽과 차단되는 것
        
    - 결함 감지
        - 결함 있는 노드를 자동으로 감지할 수 있어야 함
            - 로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.
            - 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격돼야 한다.
        - 특정 환경에서 동작하지 않는다고 명식적인 피드백 주기
            - 목적지 포트에서 수신 대기하는 프로세스가 없다면 운체에서 RST, FIN 응답(TCP 연결 닫기 or 거부)
            - 노드 프로세스가 죽고 운체가 실행중이라면 스크립트로 다른 노드에게 프로세스 죽었다고 알림
            - 데이터 센터 내 네트워크 스위치 관리에 들어가 하드웨어 수준의 링크 장애를 감지
            - 접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP Destination Unreachable 패킷으로 응답
    
    - 타임아웃과 기약 없는 지연
        - 트레이드 오프 (성능이 안 좋아지거나 오류가 많아짐)
    - 네트워크 혼잡과 큐 대기
        - 컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 딜레이가 많음
            - 네트워크 혼잡의 경우(스위치에서의 큐)
            - OS에서 운영체제의 큐에 쌓이는 경우
            - 다른 가상 장비가 CPU 코어를 차지하는 동안 어떤 데이터도 받아 들일 수 없으므로 가상 장비 모니터가 들어오는 데이터를 큐에 넣는 경우
            - TCP 흐름제어(송신율 제어)
        
        → 실험적으로 타임아웃 선택 → 긴 기간에 여러 장비에 걸쳐서 네트워크 왕복 시간 분포 측정 → 적절한 타임아웃 선택
        
    
    - 동기 네트워크 대 비동기 네트워크
        - 동기식 - 큐 대기 X → 네트워크 종단 지연 시간의 최대치 고정(제한 있는 지연)
        - 데이터센터 네트워크 와 인터넷 : 패킷 교환, 순간적으로 몰리는 트래픽에 최적화
        - 두 방식을 모두? → 하이브리드 네트워크 - 서비스 품질(패킷 우선순위), 진입 제어(전송률 제한) 를 잘 쓰면 가능
    
    ---
    
- **신뢰성 없는 시계**
    - 네트워크의 각 장비의 시간을 맞추는 방법
    
    → 네트워크 시간 프로토콜(NTP) : 서버 그룹에서 보고한 시간에 따라 컴퓨터 시계를 조정할 수 있게 하는 것
    
    - 단조 시계 대 일 기준 시계
        - 일 기준 시계
            - 직관적으로 시계에 기대하는 일, 어떤 달력에 따라 현재 날짜와 시간을 반환
            - Linux : clock.gettime(CLOCK_REALTIME)
            - NTP로 동기화됨 : 한 장비의 타임스탬프는 다른 장비의 타임스탬프와 동일한 의미를 지님
        - 단조 시계
            - 타임아웃이나 서비스의 응답 시간 같은 지속 시간을 재는 데 적합
            - Linux : clock.gettime(CLOCK_MONOTONIC)
            - 한 시점에서 단조 시계의 값을 확인하고 어떤 일을 한 후 나중에 다시 시계를 확인 → 차이
            - 로컬 시계가 NTP 서버보다 빠르거나 느리면 단조 시계가 진행하는 진도수 조정
            
    - 시계 동기화와 정확도
        - 일 기준 시계는 NTP 서버나 외부 시간 출처에 맞게 되어야 유용(단조 시계는 동기화 필요 X)
        - 정확도는 GPS 수신기, 정밀 시간 프로토콜과 세심한 배포 및 모니터링을 통해 달성할 수 있다.
        
    - 동기화된 시계에 의존하기
        - 시계가 잘못된다는 것을 눈치채지 못하기 쉬움 → 미묘한 데이터 손실이 발생할 가능성 높아짐
        - 동기화된 시계가 필요한 소프트웨어의 경우 → 모든 장비 사이의 시계 차이를 조심스럽게 모니터링해야함
        
    - 이벤트 순서화용 타임스탬프
        - 두 클라이언트가 분산 데이터베이스에 쓰면 누가 먼저 쓰게 될까?
            
            → 최종 쓰기 승리(LWW)
            
            - 리더 없는 데이터베이스에서 널리 사용
            
            —> 발생하지 않도록 NTP 동기화를 정확하게 할 수 있을까? → 불가능(네트워크 왕복 시간에 제한)
            
    - 시계 읽기는 신뢰 구간이 있다.
        - 불확실한 시점 보단 경계로 파악
        - 시간 출처를 기반으로 불확실성 경계 계산
        - Spanner에 있는 구글 트루타임(True Time)의 경우 신뢰 구간을 명시적으로 보고 (가장 이른것, 가장 느린 것)
    
    - 전역 스냅숏용 동기화된 시계
        - 스냅숏 격리 구현시 단조 증가하는 트랜잭션 id 필요
        - 데이터베이스가 여러 데이터 센터에 있는 여러 장비에 분산돼 있는 경우 전역 단조 증가 트랜잭션 id 생성 어려움
        - 동기화된 일 기준 시계 사용? → 시계 정확도에 관한 불확실성
        - Spanner의 경우 트루타입 API가 보고한 시계 신뢰 구간을 사용하여 순서 판단
        

---

- **프로세스 중단**
    - 리더 기반 복제의 경우
        - 아직 리더인지, 안전하게 쓰기를 받아들일 수 있을지 아는 법 → 리더가 다른 노드들로 부터 임차권(lease)를 얻음 → 타임 아웃이 있는 잠금
        - 시간을 정해두고 갱신 로직을 통해 리더 역할을 함 but → 프로세스의 문제가 생겨 지연돼 늦게 갱신을 날리게 되는 경우 → 임차권 만료됐음을 모름
        - 스레드가 멈추는 경우
            - GC
            - 가상 환경 장비의 서스펜드
            - 노트북 닫기
            - 컨텍스 스위치(스레드 → 스레드), 가상장비의 경우 스틸타임(가상장비 → 다른 가상 장비)
        - 해당 경우에 스레드 선점(preempt)하고 얼마간의 시간이 흐른 후 재개 → 선점된 스레드는 임차권 로직을 알아채지 못함
    - 응답 시간 보장
        - 스레드와 프로세스는 기약 없는 시간 동안 중단될 수 있음
        - 명시된 시간에 응답해야만 하는 환경의 경우 소프트웨어가 응답해야하는 데드라인 명시
        - 데드라인을 만족시키지 못하면 전체 시스템 장애 → 엄격한 실시간 시스템
        - 시스템에서 실시간 보장 = 소프트웨어 스택의 모든 수준에서 지원
        - 실시간 운영체제(RTOS) : 프로세스가 명시적 간격의 CPU 시간을 할당 받을 수 있게 보장하는 스케줄링
        - 라이브러리 함수는 최악의 실행 시간을 문서화
        - 동적 메모리 할당은 제한되거나 완전히 금지 됨(GC가 많은 일을 하지 않도록 함)
        - 막대한 양의 테스트와 측정
        - 주로 임베디드에서 사용
        
    - 가비지 컬렉션의 영향 제한하기
        - 프로세스 중단의 부정적인 영향 완화하기
        - 언어 런타임의 경우 객체 할당률과 시간에 따라 남아있는 여유 메모리 공간 추적으로 완화(GC 시점 유추가능)
        - 노드가 GC하는 동안 다른 노드가 클라이언트의 요청을 처리
            - 변종으로 수명이 짧은 객체만 GC, 수명 긴 객체 쌓이기 전에 주기적으로 프로세스 재시작