# 12장 데이터 시스템의 미래
- 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만드는 방법

## 데이터 통합
- 소프트웨어 제품과 그 제품이 잘 어울리는 환경 사이의 대응 관계를 파악하는 것이다.
  - 벤더는 적합하지 않은 작업 부하에 대해 말하기를 꺼린다.

### 파생 데이터에 특화된 도구의 결합
- 지속성 있는 레코드 시스템 : 전통적인 데이터베이스
- 복잡한 검색 기능 : 복잡한 검색 색인기 가능한 전용 도구
- 데이터베이스, 검색 색인, 분석 시스템 등  다양한 형태로 사본을 저장할 필요가 있다.

### 데이터플로에 대한 추론
- 어디서, 데이터를 처음으로 기록하는지
- 어떤 표현형이 어떤 원본에서 파생되는지
- 데이터를 모두 올바른 장소로 올바른 형식으로 어떻게 넣는지

### 파생 데이터 대 분산 트랜잭션
- 분산트랜잭션:
  - 상호 배타적인 잠금을 통해 쓰기 순서 결정
  - 원자적 커밋을 통해서 변경 효과가 정확히 한번 나타나도록 보장한다.
  - 일반적으로 선형성을 보장해준다.
  - 분산 트랜잭션 비용을 지불할 만한 제한된 환경
  - XA는 결함에 취약하고 성능도 나쁘다.

- CDC, Event Sourcing:
  - 로그 사용
  - 결정적 재시도와 멱등성에 기반

- 파생 데이터 시스템:
  - 대부분 비동기로 갱신

### 전체 순서화의 제약
- 대부분의 경우 전체 순서가 정해진 로그를 구축할 때 순서를 결정하려면 모든 이벤트가 단일 리더 노드를 통해야한다.:
  - 이벤트의 처리량이 단일 장비에서 처리할 수 있는 양보다 커진다면 복수의 장비로 파티셔닝을 해야한다. 그러면 다른 두 파티션의 이벤트 순서는 애매해진다.

- 예시:
  - 지역적으로 분산된 여러 데이터 센터에 서버가 걸쳐 있다면 일반적으로 각 데이터센터에 독립적인 리더를 둔다. 이렇게 된다면 서로 다른 데이터센터에서 나온 이벤트는 순서가 정해지지 않았다.
  - 마이크로서비스로 애플리케이션을 배포한다면, 서로 다른 서비스에서 발생한 이벤트 사이에는 정해진 순서가 없다.
  - 서버와 비동기적으로 사용자 입력에 대해 화면을 갱신한다면 이벤트 순서가 클라이언트와 서버에서 서로 다를 가능성이 높다.

- 전체 순서 브로드캐스트:
  - 전체 순서를 결정하는 것
  - 합의와 동등

### 인과성 획득을 위한 이벤트 순서화
- 인과성 문제를 해결하기 위한 출발점:
  - 논리적 타임스탬프를 사용하면 코디네이션 없이 전체 순서화를 지원할 수 있기 때문에 전체 순서 브로드캐스트를 쓸 수 없는 환경에서는 도움이 될지도 모른다. 그러나 여전히 수신자가 잘못된 순서로 전달된 이벤트를 처리해야하고 추가로 메타데이터를 전달해야한다.
  - 사용자가 결정을 내리기 전에 사용자가 본 시스템 상태를 기록하는 이벤트를 로깅할 수 있고 해당 이벤트에 고유 식별자를 부여할 수 있다면, 이후 이벤트는 인과적 의존성을 기록하기 위한 이벤트 식별자를 참조할 수 있다.
  - 충돌 해소 알고리즘은 예상치 못한 순서로 전송된 이벤트를 처리하는 데 도움을 준다. 이 알고리즘은 상태를 유지하는 데 유용하지만 활동에 외부 부수 효과가 있다면 도움이 되지 않는다.

### 일괄 처리와 스트림 처리
- 데이터 통합의 목표 : 데이터를 올바른 장소에 올바른 형태로 두는 것
- 일괄 처리와 스트림 처리의 출력 : 파생 데이터셋:
  - 검새 색인, 구체화 뷰, 사용자에게 보여주기 위한 추천, 집계 지표 등
- 일괄처리와 스트림의 근본적인 차이점:
  - 일괄처리는 유한한 크기의 입력이지만, 스트림 처리는 끝이 없는 데이터 셋 상에서 운영된다.
- 마이크로 일괄 처리: 스파크에서 스트림을 일괄처리하는 방법
- 아파치 플링크는 스트림 처리 엔진 상에서 일괄처리를 수행한다.
- 각 처리방법마다 성능 특성이 존재한다.

### 파생 상태 유지
- 일괄처리 : 함수형의 특징을 가지게 된다.
- 스트림 처리 : 함수형의 특징 뿐만 아니라 연산자를 확장해 상태를 관리하고 내결함성을 띄게 된다.
- 이론상 파생 데이터 시스템은 동기식으로 운영할 수 있다. 하지만 비동기 방식이 결함에 대해서 훨씬 견고하게 만들어준다.
- 분산 트랜잭션은 참여 장비 일부가 실패하면 어보트하기 때문에 실패가 확산 증폭되는 경향이 있다.

### 애플리케이션 발전을 위한 데이터 재처리
- 완전히 다른 보델로 새로운 요구사항을 더 잘 만족시킬수 있다.
- 점진적 발전이 가능하다. (문제가 생겼을 때 이전을 돌아갈 수 있다.)

### 람다 아키텍쳐
- 입력 데이터를 불변 이벤트로서 증가하기만 하는 데이터셋에 추가하는 방식으로 기록해야하는 것.
- 이벤트 소싱과 유사하다.
- 하둡 맵리듀스 같은 일괄 처리 시스템 또는 스톰 같은 분리된 스트림 처리 시스템과 함께 운용 된다.
- 일괄처리의 느리고 정확한 알고리즘을 채택하는 것.
- 람다 아키텍처의 단점:
  - 일괄 처리와 스트림 처리 양쪽 프레임 워크에서 같은 로직을 유지하기 위해서 상당한 노력이 요구된다.
  - 스트림 파이프라인과 일괄 처리 파이프라인은 분리도니 출력을 생산하기 떄문에 사용자 요청에 대응하기 위해 출력을 병합해야한다.
  - 전체 과거 데이터를 재처리할 수 있다는 점은 훌륭하다. 하지만 대용량 데이터 셋에서 자주 처리하기에 비용을 무시하기 어렵다. 증분처리하기에는 낙오자 처리나 겹치는 경계에서의 추가적인 처리가 필요하다.

### 일괄 처리와 스트림 처리의 통합
- 최근 이벤트 스트림을 다루는 처리엔진에서는 과거 이벤트를 재생하는 능력이 있다.
- 스트림 처리자에서는 정확히 한번 시맨틱 기능이 결함이 없었던 상황과 동일한 출력을 내는 것을 보장한다.
- 처리 시간이 기준이 아닌 이벤트 시간을 기준으로 윈도우를 처리하는 도구가 나타나고 있다.

## 데이터베이스 언번들링
- 유닉스와 관계형데이터베이스

### 데이터 저장소 기술 구성하기
- 보조색인, 구체화뷰, 복제 로그, 전문 검색 색인

#### 색인 생성하기
- `CREATE INDEX`를 실행할 떄 근본적으로 기존 데이터 셋을 재처리한다.

#### 모든 것의 메타데이터베이스
- 일괄처리와 스트림처리자
- 트리거와 스토어드 프로시저, 구체화뷰 유지 루틴

- 연합 데이터베이스:읽기를 통합
  - 엄청나게 많은 하단 저장소 엔진과 처리 메서드를 통합해 질의하는 인터페이스를 제공하는 방식
- 언번들링 데이터베이스: 쓰기를 통합
  - 여러 시스템에 걸친 쓰기를 동기화 하기 위한 방법

#### 언번들링이 동작하게 만들기
- 로그 기반 통합의 큰 장점: 느슨한 결합
  - 내결함성
  - 각자 개발, 독립적인 유지보수

#### 언번들링 대 통합 시스템
- 현재 형태의 데이터베이스를 대체하긴 어렵다.

#### 뭐가 빠졌지?
- 미분 데이터 플로

### 데이터플로 주변 애플리케이션 설계
- 함수형 반응형 프로그래밍(functional reactive programming, FRP) 언어
- 논리적 프로그래밍(logic programming)

#### 파생 함수로서의 애플리케이션 코드
- 보조 색인은 단순한 변환 함수를 사용하는 파생 데이터셋의 일종이다.
- 전문 검색 색인은 언어 가지, 단어 분리, 어간 추출, 기본형 처리, 철자교정, 동의어 식별 등의 다양한 자연어 처리 함수를 적용한 다음 효율적인 조회를 위한 자료구주를 구축한다.
- 머신러닝 시스템에서 모델은 다양한 특징 추출과 통계 분석 함수를 사용해 학습데이터로부터 파생된 것으로 간주 할 수 있다.
- 캐시는 흔히 사용자 인터페이스에 보여줄 형태의 데이터 집합을 포함한다. 즉 캐시를 채우려면 UI 에서 참조되는 필드가 무엇인지 지식이 필요하다.

#### 애플리케이션 코드와 상태의 분리
- docker, kubernetes 등 클러스터 관리 도구는 어플리케이션 코드를 수행하는 목적으로 특별히 설계되었다.
- 오늘날 대부분의 웹 어플리케이션이 상태 비저장 서비스로 배포된다.
- 데이터베이스의 내용이 변경되었는지 확인하고 싶다면 폴링이 유일한 답이다.

#### 데이터플로: 상태 변경과 애플리케이션 코드 간 상호작용
- 파생데이터를 유지하는 것이 전통적인 메시징 시스템의 설계목적인 비동기 작업 실행과는 같지 않다.:
  - 파생 데이터를 유지할 때 상태 변경 순서가 중요할 때가 존재한다.
  - 내결함성은 파생 데이터의 핵심이다.

#### 스트림 처리자와 서비스
- 어떠한 값을 처리하는 두가지 방식:
  - 서비스 또는 데이터베이스에 질의하기
  - 로컬 데이터베이스에 트래킹한 값을 적어두고 이를 사용하기:
    - 다른 서비스 장애에 잘 견딘다.
    - 빠르다.

### 파생 상태 관찰하기
- 쓰기 경로 : 파생 데이터 셋을 생성하고 최신 상태로 유지하는 과정
  - 함수형 프로그래밍의 eager evaluation
- 읽기 경로 : 파생 데이터에 대해서 질의하는 과정
  - 함수형 프로그래밍의 lazy evaluation

#### 구체화 뷰와 캐싱
- 공통 질의 캐시 : 고정된 가장 공통적인 질의 집합의 검색 결과를 미리 계산해두는 방법

#### 오프라인 대응 가능한 상태 저장 클라이언트
- 오프라인 우선(offline-first) 애플리케이션
- 일종의 서버 상태 캐시

#### 상태 변경을 클라이언트에게 푸시하기
- EventSource API, WebSocket

#### 종단 간 이벤트 스트림
- React, Flux, Redux

#### 읽기도 이벤트다
- 잠재적으로 인과적 의존성과 시스템 전체의 데이터 출처를 추적할수 있다는 이점이 있다.

#### 다중 파티션 데이터 처리

## 정확성을 목표로
### 데이터베이스에 관한 종단 간 논증
#### 연산자의 정확히 한 번 실행
- 멱등으로 만드는게 최선이다. (부수 효과를 없애야한다.)

#### 중복 억제
- 트랜잭션적 관점에서는 일반적인 중복 제거 메커니즘은 도움이 되지 않는다.

#### 연산 식별자
#### 종단 간 논증
#### 종단 간 사고를 데이터 시스템에 적용하기

### 제약 조건 강제하기
#### 유일성 제약 조건은 합의가 필요하다
#### 로그 기반 메시징의 유일성
#### 다중 파티션 요청 처리

### 적시성과 무결성
#### 데이터플로 시스템의 정확성
#### 느슨하게 해석되는 제약 조건
#### 코디네이션 회피 데이터 시스템

### 믿어라. 하지만 확인하라
#### 소프트웨어 버그가 발생해도 무결성 유지하기
#### 약속을 맹목적으로 믿지 마라
#### 검증하는 문화
#### 감사 기능 설계
#### 다시 종단 간 논증
#### 감사 데이터 시스템용 도구

## 옳은 일 하기
### 예측 분석
#### 편견과 차별
#### 칙임과 의무
#### 피드백 루프

### 사생활과 추적
#### 감시
#### 동의와 선택의 자유
#### 사생활과 데이터 사용
#### 자산과 권력으로서의 데이터
#### 산업 혁명의 기억
#### 법률과 자기 규제

