# 부호화와 발전

- 애플리케이션의 기능을 변경하기 위해서는 저장하는 데이터도 변경해야 함
- 순회식 업그레이드(단계적 롤아웃) : 몇 개의 노드에 새 버전을 배포 후 서서히 모든 노드에서 실행되게 함
- 양방향 호환성
  - 하위 호환성 : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 함
  - 상위 호환성 : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 함
  - 상위 호환성이 하위 호환성보다 어려움
  
---

- 부호화 : 인메모리 표현 -> 바이트열로의 표현
- 복호화 : 바이트열로의 표현 -> 인메모리 표현
- 부호화 라이브러리
  - 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기는 매우 어려움
  - 동일한 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 함 -> 보안 문제의 원인
  - 데이터 버전 관리를 등한시
  - 효율성이 좋지 않음

---

- JSON, XML, CSV
  - 수의 보호화에는 많은 애매함이 존재
  - 위의 애매함으로 인해 큰 수를 다룰 떄 큰 문제가 됨
  - JSON, XML 유니코드 문자열을 잘 지원하지만 이진 문자열을 지원하지 않음
  - XML, JSON 스키마를 지원함 -> 상당히 강력하지만 구현이 난해함
  - CSV 스키마를 지원하지 않음 -> 각 로우와 칼럼의 의미를 정의하는 작업은 애플리케이셔인이 해야 함

- 이진 부호화
  - JSON, XML에 비해 이진 형식은 훨씬 적은 공간을 사용
  - 메세지 팩 : JSON용 이진 부호화 형식
    - 그림 4-1

- 스리프트와 프로토콜 버퍼
  - 같은 원리를 기반으로 한 이진 부호화 라이브러리
  - 부호화할 데이터를 위한 스키마가 필요
  - 인터페이스 정의 언어로 스키마를 기술
  
  - 바이너리프로토콜
    - 그림 4-2
    - 타입 주석(annotation)
    - 길이 표시
    - 문자열을 아스키로 부호화
    - 필드 이름 X, 필드 태그를 포함(스키마 정의에 나타난 숫자)
  
  - 컴팩트프로토콜
    - 그림 4-3
    - 필드 타입과 태그 숫자를 단일 바이트로 줄이고 가변 길이 정수를 사용하여 부호화
  
  - 프로토콜 버퍼
    - 그림 4-4
    - 컴팩트프로토콜과 매우 유사

---

- 필드 태그와 스키마 발전
  - 스키마 발전 : 스키마는 필연적으로 시간이 지남에 따라 변함
  - 필드 태그는 변경할 수 없음
  - 상위 호환성 : 몇 바이트를 건너뛸 수 있는지 알려주는 데이터타입 주석을 통해 해당 필드를 무시할 수 있음
  - 하위 호환성 : 태그 번호가 계속 같은 의미를 가지고 있기 때문에 새로운 코드가 예전 데이터를 항상 읽을 수 있음
  - 하위 호환성을 유지하기 위해서는 초기 배포 후에 추가되는 모든 필드는 optional or 기본값을 가져야 함

- 데이터타입과 스키마 발전
  - 필드의 데이터타입을 변경하는 것은 불가능하지는 않지만 값이 정확하지 않거나 잘릴 위험이 있음
  
  - 프로토콜 버퍼
    - repeated 표시자 : 레코드에 동일한 필드 태그가 여러 번 나타남
    - optional 필드 -> repeated 필드 변경 가능
  
  - 스리프트 
    - 전용 목록 데이터타입 : 단일 값에서 다중 값으로의 변경 X, 중첩된 목록을 지원

---

- 아브로
  - 또 하나의 이진 부호화 형식
  - 부호화할 데이터 구조를 지정하기 위해 스키마를 사용
  - 아브로 IDL : 사람이 편집할 수 있음
  - JSON 기반 언어 : 기계가 더 쉽게 읽을 수 있음
  - 필드나 데이터타입을 식별하기 위한 정보 X
  - 데이터를 기록한 코드와 데이터를 읽는 코드가 정확히 같은 스키마를 사용해야만 올바르게 복호화 가능

  - 쓰기 스키마 : 부호하
  - 읽기 스키마 : 복호화
  - 아브로 라이브러리
    - 쓰기 스키마에서 읽기 스키마로 데이터를 변환
    - 그림 4-6
  
  - 호환성을 유지하기 위해서는 기본값이 있는 필드만 추가 or 삭제 가능
  - 필드의 데이터타입 변경 가능

  - 쓰기 스키마를 아는 방법
    - 많은 레코드가 있는 대용량 파일 : 파일의 시작 부분에 한 번만
    - 개별적으로 기록된 레코드를 가진 데이터베이스 : 레코드의 시작 부분에 버전 번호를 포함, 스키마 버전 목록 유지
    - 네트워크 연결을 통해 레코드 보내기 : 연결 설정에서 스키마 버전 합의
  
  - 동적 생성 스키마에 친숙
    - 스리프트, 프로토콜 버퍼 : 필드 태그를 수동으로 할당해야 함
  
  - 코드 생성 없이 사용할 수 있음$$

- 스키마를 사용한 이진 부호화 형식의 장점
  - 훨씬 간단하며 저 자세한 유효성 검사 규칙을 지원
  - 복호화를 할 때 스키마가 필요하기 때문에 스키마가 최신 상태임을 확신할 수 잇음
  - 부호화된 데이터에서 필드 이름을 생략할 수 있기 때문에 크기가 작음
  - 스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전 상위 호환성과 하위 호환성을 확인할 수 있음
  - 스키마로부터 코드를 생성하는 기능을 통해 컴파일 시점에 타입 체크를 할 수 있음

---

- 데이터베이스를 통한 데이터플로
  - 데이터베이스에 뭔가를 저장하는 일을 미래의 자신에게 메시지를 보내는 일처럼 생각할 수 있음
  - 그림 4-7
  - 복호화하고 다시 재부호화 하는 과정에서 알지 못하는 필드가 유실될 수 있음

- 데이터가 코드보다 더 오래 산다(data outlives code)
- 마이그레이션 하는 작업은 값비싼 작업
- 기존 데이터를 다시 기록하지 않고 null을 기본값으로 갖는 새로운 칼럼을 추가
- 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 보이게 함

- 보관 저장소
  - 데이터 텀프는 보통 최신 스키마를 사용해 부호화
  - 한 번에 기록하고 이후 변하지 않으므로 아브로 객체 컨테이너 파일과 같은 형식이 적합

---

- 서비스를 통한 데이터 플로 : REST와 RPC
  - 클라이언트, 서버 두 역할
  - 서비스 : 서버가 공개한 API
  - 서비스 지향 설계, 마이크로서비스 설계 : 하나의 서비스가 다른 서비스의 일부 기능이다 데이터가 필요하다면 해당 서비스에 요청을 보냄
  - 서비스는 비즈니스 로직으로 미리 정해진 입력과 출력만 허용한 애플리케이션 특화 API를 공개
  - **서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능해야 함**

- 웹 서비스
  - 사용되는 상황
    - 사용자 디바이스에서 실행하며 HTTP를 통해 서비스에 요청하는 클라이언트 애플리케이션
    - 서비스 지향/마이크로서비스 아키텍처의 일부로서 대게 같은 데이터센터에 위치한 같은 조직의 다른 서비스에 요청하는 서비스
    - 인터넷을 통해 다른 조직의 서비스에 요청하는 서비스 ex)Oauth

  - REST : HTTP의 원칙을 토대로 한 설계 철학
    - 간단한 데이터 타입을 강조, URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP 기능을 사용
    - RESTful : REST 원칙에 따라 설계된 API
  
  - SOAP : 네트워크 API 요청을 위한 XML 기반 프로토콜
    - HTTP와 독립적
    - 웹 서비스 프레임워크를 제공
    - WDSL(Web SErvices Description Language) : 클라이언트가 로컬 클래스와 매서드 호출을 사용해 원격 서비스에 접근하는 코드 생성이 가능
    - 정적 타입 프로그래밍 언어에는 유용, 동적 타입 언어에는 유용성이 떨어짐
    - SOAP 사용자는 도구 지원, 코드 생성, IDE에 크게 의존
  
---

- 웹 서비스의 많은 부분이 과장됐고 여러 심각한 문제가 있음
- 웹 서비스는 원격 프로시저 호출(RPC)의 아이디어를 기반으로 함
  
- RPC 모델
  - 위치 투명성 : 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해줌
  - 네트워크 문제로 요청과 응답이 유실되거나 원격 장비가 느려지거나 요청에 응답하지 않을 수 있음
  - 문제점
    - 네트워크 요청은 타임아웃으로 결과 없이 반환될 수 있음 
    - 실패한 네트워크 요청을 다시 시도할 떄 요청이 실제로는 처리되고 응답만 유실될 수 있음
    - 네트워크 요청은 함수 호출보다 훨씬 느리고 지연 시간은 매우 다양함
    - 네트워크로 요청하는 경우에는 모든 매개변수는 네트워크를 통해 전송할 수 있게끔 바이트열로 부호화해야 함
    - 클라이언트와 서비스가 다른 프로그래밍 언어로 구현된 경우 RPC 프레임워크는 하나의 언어에서 다른 언어로 데이터타입을 변환해야 함
  
  - 차세대 RPC 프레임워큰느 원격 요청이 로컬 함수 호출과 다르다는 사실을 더욱 분명히 함
  - 퓨처 : 병렬로 여러 서비스에 요청을 보내야 하는 상황을 간소화하고 요청 결과를 취합함
  - 서비스 찾기 : 클라이언트가 특정 서비스를 찾을 수 있는 IP 주소와 포트 번호를 제공

- RESTful API는 실험과 디버깅에 적합, 모든 주요 프로그래밍 언어와 플랫폼이 지원하고 사용 가능한 다양한 도구 생태계가 있음
- RPC 프레임워크의 주요 초점은 보통 같은 데이터센터 내의 같은 조직이 소유한 서비스 간 요청에 있음

---

- 비동기 메시지 전달 시스템(asynchronous message passing system)
  - 낮은 지연시간으로 다른 프로세스에 전달 -> RPC와 유사
  - 메세지를 직접 네트워크 연결로 전송하지 않고 임시로 메세지를 저장하는 메세지 브로커 or 메세지 지향 미들웨어 -> 데이터베이스와 유사
  - 메세지 브로커를 사용하는 장점
    - 수신자가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있기 때문에 시스템 안정성이 향상
    - 죽었던 프로세스에 메시지를 다시 전달할 수 있기 때문에 메시지 유실을 방지할 수 있음
    - 송신자가 수신자의 IP 주소나 포트 번호를 알 필요가 없음
    - 하나의 메시지를 여러 수신자로 전송할 수 있음
    - 논리적으로 송신자는 수신자와 분리
  - 비동기 : 송신 프로세스는 메시지가 전달될 때까지 기다리지 않고 단순히 메시지를 보낸 다음 잊음

- 메시지 브로커
  - 프로세스 하나가 메시지를 이름이 지정된 큐나 토픽으로 전송, 브로커는 해당 큐나 토픽 하나 이상의 소비자 또는 구독자에게 메시지를 전달
  - 토픽은 단방향 데이터플로만 제공

- 액터 모델 : 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델
  - 스레드를 직접 처리하는 대신 로직이 액터에 캡슐화됨
  - 비동기 메시지의 송수신으로 다른 액터와 통신
  - 메시지 전달을 보장하지 않음
  - 각 액터는 프레임워크와 독립적으로 실행할 수 있음

- 분산 액터 프레임워크
  - 메시지 브로커와 액터 프로그래밍 모델을 단일 프레임워크에 통합
  - 아카
  - 올리언스
  - 얼랭

- 정리
  - 데이터 구조를 바이트열로 변환하는 다양한 방법
  - 하위 호환성, 상위 호환성을 제공하는 방식으로 부호화

  