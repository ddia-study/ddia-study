# 11장 스트림 처리

- 스트림 처리 : 고정된 시간 조각이라는 개념을 버리고 단순히 이벤트가 발생할 때마다 처리해야 한다.

## 이벤트 스트림 전송
- 이벤트 : 특정 시점에 일어난 사건에 대한 세부 사항을 포함하는 작고 독립된 불변 객체
  - 일반적으로 일 기준 시계를 따르는 이벤트 발생 타임스탬프를 포함한다.
- 생산자(producer), 발행자(publisher), 발송자(sender)
- 소비자(consumer), 구독자(subscriber), 수신자(recipient)
- 전통적인 데이터베이스에는 스트리밍 시스템을 위한 별도의 알림 메커니즘이 존재하지 않는다.
  - 트리거(trigger) 기능을 사용해서 제한적으로나마 구현한다.

## 메시징 시스템
- 메시징 시스템을 구축하는 가장 간단한 방법: 유닉스 파이프나 TCP 연결
- 발행/구독(publish/subscribe) 모델에서 고려할점:
  - 메시지를 처리하는 속도보다 더 빠르게 메시지가 전송(생성) 된다면?:
    - 메시지 버리기, 버퍼링, 흐름제어
  - 노드가 죽거나 일시적으로 오프라인이 된다면:
    - 디스크에 기록하거나 복제본 생성

### 생산자에서 소비자로 메시지를 직접 전달하기
- 낮은 지연시간이 필수인 곳 : UDP Multicast
- 브로커가 없는 일반적인 상황 : TCP/IP Multicast
- Consumer가 네트워크에 직접 서비스를 노출할 경우 : HTTP, RPC

- 모두 메시지 유실을 방지하기 위해서 잘 작성해야하며, 소비자가 오프라인이 되거나 하는 등의 문제가 발생하여 메시지 버퍼 자체를 잃어버리는 경우도 있다.

### 메시지 브로커
- 메시지 큐라고도 불림
- 생산자와 소비자는 브로커의 클라이언트가, 브로커는 일종의 서버가 되어 메시지를 중개한다.
- 지속성 문제를 생산자, 소비자로 부터 브로커로 옮기면서 관심사 분리가 일어난다.
- 메시지 브로커는 디스크에 미시지를 기록하거나, 큐 사이즈를 변경하는 등 다양한 설정을 제공하여 적절하게 변경하여 사용 가능하다.
- 일반적으로, 비동기적으로 동작한다.

### 메시지 브로커와 데이터베이스의 비교
- 데이터베이스는 명시적으로 데이터가 삭제될 때까지 데이터를 보관한다. 메시지 브로커 대부분은 소비자에게 데이터 배달이 성공할 경우 자동으로 메시지를 삭제한다. 즉 오랜 기간 데이터를 저장하는 용도로는 데이터베이스가 더 적합하다.
- 메시지 브로커는 대부분 메시지를 빨리 지우기 때문에 작업 집합이 상당히 작다고 가정한다. 즉 큐의 크기가 작고, 소비자가 느려서 메시지 브로커가 많은 메시지를 버퍼링해야한다면 개별 메시지 처리 시간이 길어지고 전체 처리량이 저하된다.
- 데이터베이스는 보조 색인을 지원하고 데이터 검색을 위한 다양한 방법을 지원하는 반면 메시지 브로커는 특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식을 지원한다. 메커니즘은 다르지만 둘 다 본질적으로 클라이언트가 데이터에서 필요한 부분을 선택하는 방법이다.
- 데이터베이스에 질의할 때 그 결과는 일반적으로 질의 시점의 데이터 스냅숏을 기준으로 한다. 다른 클라이언트가 이어서 질의 결과를 바꾸는 어떤 데이터를 데이터베이스에 기록한다면 첫번째 클라이언트는 다시 질의하거나 , 데이터 변화를 폴링 하지 않는다면 앞선 결과가 기간이 지나 유효하지 않다는 점을 알 길이 없다. 반대로 메시지 브로커는 임의 질의를 지원하지 않지만 데이터가 변하면 클라이언트에게 알려준다.
- RabbitMQ, ActiceMQ, Qpid, HornetQ, Azure Service Bus

### 복수 소비자
- 로드 밸런싱:
  - 각 메시지는 소비자 중 하나로 전달된다. 따라서 소비자들은 해당 토픽의 메시지를 처리하는 작업을 공유한다. 브로커는 메시지를 전달하는 소비자를 임의로 지정한다. 이를 공유 구독으로 부르기도 한다.
- 팬 아웃:
  - 각 메시지는 모든 소비자에게 전달된다. 팬 아웃 방식을 사용하면 여러 독립적인 소비자가 브로드캐스팅 된 동일한 메시지로 서로 간섭 없이 청취할 수 있다.

### 확인 응답과 재전송
- 메시지 브로커는 메시지를 잃어버리지 않기 위해 확인 응답을 사용한다.
- 메시지 간 인과성이 있을 수 있기에 메시지 순서를 유지하기 위해서 노력한다.

### 파티셔닝된 로그
- 로그 기반 메시지 브로커(log-based message broker):
  - 데이터베이스의 지속성 있는 저장 방법과 메시징 시스템의 지연시간이 짧은 알림 기능을 조합한다.

#### 로그를 사용한 메시지 저장소
- 로그를 파티셔닝하여 처리량을 높인다.
- 각 파티션 내에서 브로커는 모든 메시지에 단조증가하는 순번인 오프셋을 부여한다.
- Apache Kafka, Amazon Kinesis Stream, DistributedLog

#### 로그 방식과 전통적인 메시징 방식의 비교
- 로그 기반 접근법은 팬 아웃 메시징 방식을 제공한다.
- 단점:
  - 토픽 하나를 소비하는 작업을 공유하는 노드의 수는 많아야 해당 토픽의 로그 파티션 수로 제한된다.
  - 선두차단(head-of-line blocking) 형태로, 특정 메시지 처리가 느리면 나머지 메시지 처리 또한 지연된다.

#### 소비자 오프셋
- 로그 순차 번호(log sequence number)와 유사하게 메시지 오프셋은 동작한다.

#### 디스크 공간 사용
- 원형 버퍼(circular buffer) 또는 링 버퍼(ring buffer)
- 로그는 크기가 제한된 버퍼로 구현하고 버퍼가 가득 차면 오래된 메시지 순서대로 버린다.

- 큐가 작을때는 빠르지만, 디스크에 기록하기 시작하면 매우 느려진다.

#### 소비자가 생산자를 따라갈 수없을 때
- 메시지 버리기, 버퍼링, 배압 적용하기
- 소비자가 죽더라도 오프셋은 남아 재개 가능하다. (전통적인 메시지 브로커는 소비자가 죽으면 소비자에게 할당된 큐를 삭제해야한다.)

#### 오래된 메시지 재생
- 메시지 처리의 유일한 부수효과 : 소비자 오프셋 이동
- 입력 데이터에 영향을 전혀 주지 않고 파생 데이터를 만든다.

## 데이터베이스와 스트림
- 데이터베이스와 스트림은 이종 데이터 시스템이다.
- 이 둘의 장점을 각각 사용하기 위해서 두가지 시스템을 사용할 때 발생하는 다른 문제를 해결한다.

### 시스템 동기화 유지하기
- 이중 기록(dual write):
  - 데이터베이스와 검색 색인이 별도로 분리되어 있을 때, 동기 쓰기가 발생하면 불일치가 발생할 수 있다.
  - 이를 해결하기 위해서는 데이터 시스템간의 합의 또는 2PC와 같은 원자적 커밋 방법이 필요하다.

### 변경 데이터 캡처
- 변경 데이터 캡처(change data capture, CDC):
  - 데이터베이스에 기록하는 모든 데이터의 변화를 관찰해 다른 시스템으로 데이터를 복제할 수 있는 형태로 추출하는 과정

#### 변경 데이터 캡처의 구현
- 변경 사항을 캡처할 데이터베이스 하나를 리더로 설정, 나머지는 팔로워로 설정한다.
- 로그 기반 메시지 브로커 또는 데이터베이스 트리거를 사용한다.:
  - 로그 기반 메시지 브로커는 메시지 순서를 보장하므로 몇가지 문제에서 해방된다.
  - 데이터베이스 트리거는 고장나기도 쉽고 성능 오버헤드가 있다.
- 복제로그 파싱:
  - 데이터베이스에 쓰이는 로그를 분석하여 데이터 캡처를 구현하는 방식
  - Bottled Water, Maxwell, Debezium, Mongoriver 등

#### 초기 스냅숏
- 모든 변경 로그를 저장하기에는 저장공간 및 재생 시간 측면에서 효율적이지 않다.
- 따라서 적당히 로그를 잘라야한다. 이때 로그 뿐만이 아니라 순간의 스냅숏 또한 필요해진다.

#### 로그 컴팩션
- 로그 컴팩션 : 저장 엔진은 주기적으로 같은 키의 로그 레코드를 찾아 중복을 제거하고 각 키에 대해 가장 최신 갱신 내용만을 유지하는것.
- Kafka는 이미 로그 컴팩션 기능을 제공한다.

#### 변경 스트리밍용 API 지원
- 최신 데이터베이스들은 기본 인터페이스로 변경 스트리밍 API를 제공하기 시작했다.

### 이벤트 소싱
- 이벤트 소싱 : 어플리케이션 상태 변화를 모두 변경 이벤트 로그로 저장한다.
- 이벤트 소싱과 변경데이터 캡처 비교:
  - 변경 데이터 캡처에서 애플리케이션은 데이터베이스를 변경 가능한 방식으로 사용해 레코드를 자유롭게 갱신하고 삭제한다. 변경 로그는 데이터베이스에서 저수준으로 추출한다. 변경 로그는 데이터베이스에서 추출한 쓰기 순서가 실제로 데이터를 기록한 순서와 일치하고 경쟁조건이 나타나지 않게 보장한다. 데이터베이스에 기록하는 애플리케이션은 CDC가 실행중인지 알 필요가 없다.
  - 이벤트 소싱에서 애플리케이션 로직은 이벤트 로그에 기록된 불변 이벤트를 기반으로 명시적으로 구축한다. 이벤트 저장은 추가만 가능하고 갱신이나 삭제는 권장하지 않거나 금지한다. 이벤트는 저수준에서 상태 변경을 반영하는 것이 아니라 애플리케이션 수준에서 발생한 일을 반영하게끔 설계한다.

#### 이벤트 로그에서 현재 상태 파싱하기
- 레코드 갱신용 CDC 이벤트는 일반적으로 레코드의 가장 새로운 버전을 보유한다. 그래서 기본키의 현재 값은 전적으로 기본키의 가장 최신 이벤트로 결정되고 이전 이벤트는 로그 캠팩션을 통해 버린다.
- 이벤트 소싱에서 이벤트는 사용자 행동의 결과로 발생한 상태 갱신 메커니즘이 아닌 사용자 행동 의도를 표현한다. 따라서 마지막 상태를 구축하기 위해서는 이벤트의 전체 히스토리가 필요하다.

#### 명령과 이벤트
- 명령은 사용자 요청이 처음 도착하였을때,
- 이벤트는 명령이 무결성이 검증되고 승인되었을 때이다.

### 상태와 스트림 그리고 불변성
- 상태가 변할 때마다 해당 상태는 시간이 흐름에 따라 변한 이벤트의 마지막 결과이다.

#### 불변 이벤트의 장점
- 감사 기능
- 현재 상태보다 훨씬 많은 정보를 포함한다.

#### 동일한 이벤트 로그로 여러가지 뷰 만들기
- CQRS(Command Query Responsibility Segregation)

#### 동시성 제어
- 이벤트 소싱, CDC (이하 스트림)의 단점은 스트림의 소비가 비동기로 이뤄지기에 사용자에게 반영되지 않았을 수 있다.
- 빠르게 사용자에게 먼저 보이고 싶다면 스트림에 넣으면서 사용자 뷰에 선반영하면 된다.
- 이러기 위해서는 스트림과 사용자 뷰가 저장된 시스템이 동기화 문제가 없어야한다.

#### 불변성의 한계
- 볍적인 문제로 인해서 로그를 지워야할 때가 있다. 이러한 기능을 적출(exicision) 또는 셔닝(shunning)이라고 부른다.
- 모든 복제본을 삭제해야 하므로, 이는 쉽지 않은 문제이다.

### 스트림 처리
- 스트림을 처리하는 방법 3가지:
  - 데이터베이스나 캐시, 검색 색인 등 다른 저장소 시스템에 기록 후 이를 클라이언트가 질의
  - 이벤트를 사용자에게 보냄. (이메일, 푸쉬 알림 등)
  - 출력스트림을 생산

### 스트림 처리의 사용
#### 복잡한 이벤트 처리
- CEP(Complex Event Processing):
  - 스트림에서 특정 이벤트 패턴을 찾는 규칙 지정
  - 질의와 데이터의 역할 역전:
    - 질의는 오랜 기간 저장, 이벤트는 해당하는 질의를 찾으면서 스트림을 지나감

#### 스트림 분석
- 집계 예시:
  - 특정 유형의 이벤트 빈도 측정
  - 특정 기간에 걸친 이동 평균 계산
  - 이전 시간 간격과 현재 통계값의 비교

- 윈도우:
  - 이러한 집계 기간의 시간 간격

- 성능 최적화를 위해서 확률적 알고리즘을 사용하기도 한다.

#### 구체화 뷰 유지하기
- 파생 데이터시스템(캐시, 검색 색인, 데이터 웨어하우스 등)에서 구체화 뷰를 유지하고, 이러한 파생 데이터 시스템에 질의

#### 스트림 상에서 검색하기
- Elastic Search의 percolator(여과) 기능
- CEP와 유사하게 문서가 질의를 지나가면서 실행된다.

#### 메시지 전달과 RPC
- 액터와 스트림처리자 비교:
  - 액터 프레임워크는 주로 동시성을 관리하고 통신 모듈을 분산 실행하는 메커니즘, 스트림 처리는 데이터 관리 기법
  - 액터 간 통신은 주로 단기적이고 일대일, 이벤트 로그는 지속성이며, 다중 구독 가능
  - 액터는 임의의 방식으로 통신할 수 있다. 스트림 처리자는 대부분 비순환 파이프라인에서 실행

- 아파치 스톰에서 분신 RPC와 같은 기능을 통해서 이벤트 스트림을 처리하는 기능도 있다.
- 액터 프레임워크를 이용해 스트림 처리를 할 수도 있으나, 장애에 대해 메시지 전달을 보장하지 않기에 내결함성을 위해서는 추가적인 구현이 필요하다.

### 시간에 관한 추론
- 우리가 생각하는 시간 단위만큼 간단하지 않다.
- 일괄처리(batch processing)은 타임스탬프를 통해 결과를 결정적으로 만들수 있지만, 스트림 처리는 그렇지만은 않다.
- 장비의 시스템 시계를 이용하면 간단하다는 장점이 있지만, 이벤트 생성과 이벤트 처리 사이의 간격을 고려는 해야한다.

#### 이벤트 시간 대 처리 시간
- 요청이 일괄적으로 들어오더라도, 스트림 처리자에 대해서 재배포를 할 경우 재배포 직후 순간적으로 요청이 증가한것처럼 스트림 처리자는 인식한다.

#### 준비 여부 인식
- 낙오자 이벤트에 대한 처리:
  - 낙오자 이벤트를 무시한다. (일반적으로 굉장히 낮은 비율이기에)
  - 수정 값을 발행한다.

#### 어쨋든 어떤 시계를 사용할 것인가?
- 세가지 타임 스탬프를 로그로 남긴다.:
  - 이벤트가 발생한 시간, 장치 시계를 따른다.
  - 이벤트를 서버로 보낸 시간, 장치 시계를 따른다.
  - 서버에서 이벤트를 받은 시간, 서버 시계를 따른다.
- 위 3가지 타임스탬프를 조합하면 장치 시계와 서버 시계간의 차이를 추정할 수 있고, 네트워크 지연을 작다고 가정하고 실제 발생 시간을 처리한다.

#### 윈도우 유형
- 텀블링 윈도우(Tumbling Window):
  - 고정 길이, 모든 이벤트는 정확히 한 윈도우에만 속한다.
- 홉핑 윈도우(Hopping window):
  - 고정 길이, 결과를 매끄럽게 하기 위해서 윈도우를 중첩할 수 있다.
- 슬라이딩 윈도우(Sliding window):
  - 각 시간 간격 사이 이벤트를 포함한다. 동일한 이벤트에 대해 상대적으로 과거의 만료된 이벤트를 제거하는 방식으로 윈도우 내의 이벤트 중복을 제거할 수 있다.
- 세션 윈도우(Session window):
  - 고정된 기간이 없고, 같은 사용자가 짧은 시간 동안 발생시킨 모든 이벤트를 그룹화 해서 정의한다.
  - 웹사이트 분석을 할때 흔히 필요하다. 일정시간(예 : 30분)간 아무런 이벤트가 없으면 윈도우를 제거한다.

### 스트림 조인
- 조인 유형 구분:
  - 스트림 스트림 조인, 스트림 테이블 조인, 테이블 테이블 조인

#### 스트림 스트림 조인(윈도우 조인)
- 스트림 처리자가 상태를 유지하여(예 : 세션 ID), 이를 사용하여 조인한다.

#### 스트림 테이블 조인(스트림 강화)
- 스트림에 추가적인 정보를 넣어준다. (흔히 테이블도 시간에 따라 변화하는 경우)
- 흔히 강화(enriching) 한다고 한다.
- 이는 스트림만 보고 스트림 처리자가 처리할 수있게 해준다.

#### 테이블 테이블 조인(구체화 뷰 유지)
- 테이블이 바뀔때마다 구체화 뷰도 갱신되는 특징을 사용해 일종의 캐시처럼 사용한다.

#### 조인의 시간 의존성
- 복수 개의 스트림을 조인하게 된다면, 각 스트림 간의 이벤트 순서를 결정해줘야한다. 그렇지 않는다면 조인도 비결정적이게 된다.
- SCD(Slowly Changing Dimension), 천천히 변하는 차원

### 내결함성
- 결과적으로 한번(effectively-once), 정확히 한번 시맨틱(ㄷxactly-once semantics)

#### 마이크로 일괄 처리와 체크포인트
- 마이크로 일괄처리 : 스트림을 작은 블록으로 나누고, 각 블록을 소형 일괄 처리와 같이 다룬다.
- 체크포인트 : 주기적으로 롤링 체크포인트를 생성하고 지속 성 있는 저장소에 저장하여, 스트림 연산자에 장애가 발생하더라도 가장 최근 체크포인트에서 재시작하여 장애를 대처한다.

#### 원자적 커밋 재검토
- 내부적으로 트랜잭션을 유지한다.

#### 멱등성
- 멱등 연산에 의존하여 장애에 대처하며, 정확히 한번 시맨틱을 달성시킨다.

#### 실패 후에 상태 재구축하기
- 원격 데이터 저장소에 상태를 유지하고 복제하여 데이터 손실없이 처리한다.
- 또는 입력 스트림을 사용해 재구축한다.

---
위의 여러가지 방법들은 모두 트레이드 오프가 있기에 적절하게 선택하여 사용해야 한다.
