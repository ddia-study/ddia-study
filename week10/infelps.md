# 일관성과 합의

- 내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것이다.
	- 합의 : 모든 노드가 어떤 것에 동의하게 만드는 것
	- 단일 리더 복제를 하는 데이터베이스 -> 합의를 사용해 새 리더를 뽑을 수 있다.

- 어떤 것을 할 수 있고 어떤 것을 할 수 없는지에 대한 범위를 이해해야 한다.

## 일관성 보장

- 복제 데이터베이스는 대부분 최소한 최종적 일과성을 제공한다.
- 매우 약한 보장, 언제 복제본이 수렴될지에 대해서는 아무것도 얘기하지 않는다.
- 단일 스레드 프로그램에 있는 변수의 동작과 매우 다르므로 개발자에게 어렵다.
- 약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 계속 알아야 하고 뜻하지 않게 너무 많은 것을 가정하면 안 된다.
- 데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 살표본다.

## 선형성

- 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것이다.
- 최신성 보장(recency guarantee) : 읽힌 값이 최근에 갱신된 값이며 뒤처진 캐시나 복제본에서 나온 값이 아니라고 보장
- 그림 9-1 (비선형성)

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 선형성을 뒷받침하는 기본 아이디어는 시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만드는 것이다.
- 그림 9-2
	- 네트워크 지연의 변동 때문에 클라이언트는 데이터베이스가 언제 자신의 요청을 처리했는지 정확히 알지 못한다.
- 그림 9-3
	- 선형성 시스템에서 우리는 x의 값이 원자적으로 0에서 1로 바뀌는 어떤 시점이 있다고 상상한다.
- 그림 9-4
	- 읽기와 쓰기 외에 세 번째 종류의 연산을 추가한다.(compare-and-set)
	- 연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고 결코 뒤로 가서는 안 된다는 것이다.

- 직렬성
	- 직렬성은 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다.
- 선형성
	- 선형성은 레지스터에 실행되는 읽기와 쓰기에 대한 최신성 보장이다.

### 잠금과 리더 선출

- 리더를 선출하는 한 가지 방법은 잠금을 사용하는 것이다.
- 이 잠금을 어떻게 구현하든지 선형적이어야 한다.
- 아파치 주키퍼, etcd : 분산 잠금, 리더 선출, 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.
- RAC는 여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근하며 디스크 페이지마다 잠금을 사용한다.

### 제약 조건과 유일성 보장

- 데이터가 기록될 때 유일성 제약 조건을 강제하고 싶다면 선형성이 필요하다.
- (계좌 잔고, 재고 수준, 좌석 점유) 모든 노드가 동의하는 하나의 최신 값이 있기를 요구한다.
- 관계형 데이터베이스에서 전형적으로 볼 수 있는 엄격한 유일성 제약 조건은 선형성이 필요하다.

### 채널 간 타이밍 의존성

- 선형성 위반은 시스템에 부가적인 통신 채널이 있었기 때문에 발견됐다.
- 그림 9-5
- 선형성의 최신성 보장이 없으면 두 채널 사이에 경쟁 조건이 발생할 수 있다.
- 선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기에 가장 단순하다.

### 선형성 시스템 구현하기

- 단일 리더 복제(선형적이 될 가능성이 있음) : 리더는 쓰기에 사용되는 데이터의 주 복사본을 갖고 있고 팔로워는 다른 노드에 데이터의 백업 복사본을 보관한다. 리더나 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다.
- 합의 알고리즘(선형적) : 합의 프로토콜에는 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수단이 포함된다. 주키퍼, etcd
- 다중 리더 복제(비선형적) : 여러 노드에서 동시에 쓰기를 처리하고 그렇게 쓰여진 내용을 비동기로 다른 노드에 복제하기 때문에 일반적으로 선형적이지 않다.
- 리더 없는 복제(아마도 비선형적) : "최종 쓰기 승리" 충돌 해소 방법은 거의 확실히 비선형적이다. 느슨한 정족수도 선형성의 가능성을 망친다. 엄격한 정족수를 사용해도 비선형적으로 동작할 가능성이 있다.

### 선형성과 정족수

- 그림 9-6
- 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는 게 가장 안전하다.

### 선형성의 비용

- 그림 9-7
- 두 데이터센터 사이에 네트워크가 끊기는 경우
- 다중 리더 복제 : 각 데이터센터는 계속 정상 동작할 수 있다. 한 데이터센터에 쓰여진 내용이 비동기로 다른 데이터센터로 복제되므로 쓰기는 그냥 큐에 쌓였다가 네트워크 연결이 복구되면 전달된다.
- 단일 리더 복제 : 팔로워 데이터센터로 접속한 클라이언트들은 리더로 연결할 수 없으므로 데이터베이스에 아무것도 쓸 수 없고 선형성 읽기도 전혀 할 수 없다.

### CAP 정리

- 트레이드오프
	- 애플리케이션에서 선형성을 요구하고 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리할 수 없다. 가용성이 없다.
	- 애플리케이션에서 선형성을 요구하지 않는다면 각 복제 서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있다. 가용한 상태를 유지하지만 선형적이지 않다.

- CAP 정리
	- 일관성, 가용성, 분단 내성이라는 세 개 중 두 개를 고르라는 것으로 표현된다. 네트워크 분단이 생겼을 떄 일관성과 가용성 중 하나를 선택하라는 의미
	- https://johngrib.github.io/wiki/CAP-theorem/

### 선형성과 네트워크 지연

- 다중코어 CPU의 램(RAM)조차 선형적이지 않다.
- 선형성을 제거한 이유는 내결함성이 아니라 성능이다.
- 선형성을 원하면 읽기와 쓰기 요청의 응답 시간이 적어도 네트워크 지연의 불확실성에 비례해야 함을 증명했다.
- 대부분의 컴퓨터 네트워크처럼 지연의 변동이 매우 심한 네트워크에서 선형성 읽기와 쓰기의 응답 시간은 필연적으로 높아진다.

## 순서화 보장

- 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있다.

### 순서화와 인과성

- 순서화가 인과성을 보존하는 데 도움을 준다.
- 인과성은 이벤트에 순서를 부과한다. 결과가 나타나기 전에 원인이 발생한다.
- 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적이라고 한다.

### 인과적 순서가 전체 순서는 아니다

- 전체 순서는 어떤 두 요소를 비교할 수 있게 하므로 두 요소가 있으면 항상 어떤 것이 더 크고 어떤 것이 더 작은지 말할 수 있다.
- 수학적 집합은 비교불가하고 부분적으로 순서가 정해진다.
- 선형성
	- 선형성 시스템에서는 연산의 전체 순서를 정할 수 있다.
- 인과성
	- 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만, 이들이 동시에 실행되면 비교할 수 없다. 
	- 인과성이 전체 순서가 아닌 부분 순서를 정의한다.

- 선형성 데이터스토어에는 동시적 연산이 없다.
- 하나의 타임라인이 있고 모든 연산은 그 타임라인을 따라서 전체 순서가 정해져야 한다.
- 동시성은 타임라인이 갈라졌다 다시 합쳐지는 것을 의미한다. 이 경우 다른 가지에 있는 연산은 비교 불가하다.
- 깃의 버전 히스토리는 인과적 의존성 그래프와 매우 유사하다.

### 선형성은 인과적 일관성보다 강하다

- 선형성은 인과성을 내포한다.
- 시스템을 선형성으로 만들면 성능과 가용성에 해가 될 수 있다.
- 선형성은 인과성을 보존하는 유일한 방법이 아니다.
- 많은 경우에 선형성이 필요한 것처럼 보이는 시스템에 사실 진짜로 필요한 것은 인과적 일관서이며 이는 더 효율적으로 구현될 수 있다.

### 인과적 의존성 담기

- 인과성을 유지하기 위해 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다.(부분 순서)
- 전체 데이터베이스에 걸친 인과적 의존성을 추적해야한다. 이를 위해 버전 벡터를 일반화할 수 있다.
- 인과적 순서를 결정하기 위해 데이터베이스는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 한다.

### 일련번호 순서화

- 인과성은 중요한 이론적 개념이지만 모든 인과적 의존성을 실제로 추적하는 것은 실용성이 떨어진다.
- 일련번호나 타임스탬프를 써서 이벤트의 순서를 정할 수 있다.
- 일련번호나 타임스탬프는 크기가 작고 전체 순서를 제공한다.
- 인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있다.

### 비인과적 일련번호 생성기

- 단일 리더가 없는 경우
	- 각 노드가 자신만의 독립적인 일련번호 집합을 생성할 수 있다. 일련번호의 이진 표현에서 몇 비트를 예약해서 고유 노드 식별자를 포함할 수 있다.
	- 각 연산에 일 기준 시계에서 얻은 타임스탬프를 붙일 수 있다. 순차적이지 않지만 해상도가 충분이 높다면 연산의 전체 순서를 정하는 데 충분할 수 있다.
	- 일련번호 블록을 미리 할당할 수 있다.

- 생성한 일련번호 인과성에 일관적이지 않다.
- 인과성 문제
	- 각 노드는 초당 연산수가 다를 수 있다.
	- 물리적 시계에서 얻은 타임스탬프는 시계 스큐에 종속적이어서 인과성에 일관적이지 않게 될 수 있다.
	- 1001과 2000 사이의 구간에서 일련번호를 받고, 나중에 실행되는 연산이 1과 1000사이의 구간에서 일련번호를 받을 수 있다.

### 램포트 타임스탬프

- 그림 9-8
- 각 노드는 고유 식별자를 갖고 각 노드는 처리한 연산 개수를 카운터로 유지한다.
- 램포트 타임스탬프 -> (카운터, 노드 ID)
- 두 노드는 때때로 카운터 값이 같을 수 있지만 타임스탬프에 노드 ID를 포함시켜서 각 타임스탬프는 유일하게 된다.
- 램포트 타임스탬프는 물리적 일 기준 시계와 아무 관련이 없지만 전체 순서화를 제공한다.
- 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크다. 
- 카운터 값이 같으면 노드 ID가 큰 것이 타임스탬프가 크다.
- 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓갑을 추적하고 모든 요청에 그 최댓값을 포함시킨다.
- 버전 벡터와의 차이점
	- 버전 벡터는 두 연산이 동시적인지 또는 어떤 연산이 다른 연산에 인과적으로 의존하는지 구분할 수 있지만 램포트 타임스탬프는 항상 전체 순서화를 강제한다.
	- 램포트 타임스탬프의 전체 순서화로부터 두 연산이 동시적인지 또는 인과적으로 의존성이 있는지를 알 수 없다.
	- 램포트 타임스탬프의 크기가 더 작다.

### 타임스탬프 순서화로는 충분하지 않다.

- 사용자명으로 사용자 계정을 유일하게 식별할 수 있도록 보장해야 하는 시스템
	- 시스템에서 사용자명 생성 연산을 모두 모으면 그들의 타임스탬프를 비교할 수 있다.
	- 노드가 사용자로부터 사용자명 생성 요청을 막 받고 그 요청이 성공해야 하는지 실패해야 하는지 당장 결정해야 할 때는 이 방법으로는 부족하다.
	- 다른 어떤 노드도 계정 생성을 처리하는 중이 아니라고 확신하려면 다른 모든 노드가 무엇을 하고 있는지 확인해야 한다.
	- 사용자명에 대한 유일성 제약 조건 같은 것을 구현하려면 연산의 전체 순서가 있는것으로는 충분치 않고, 언제 그 순서가 확정되는지도 알아야 한다.

### 전체 순서 브로드캐스트

- 분산 시스템에서는 모든 노드에서 연산의 전체 순서가 동일하도록 합의하기가 까다롭다.
- 전체 순서 브로드캐스트, 원자적 브로드캐스트
	- 처리량이 단일 리더가 처리할 수 있는 수준을 넘어설 때 시스템을 어떻게 확장할 것인가와 리더에 장애가 발생했을 때 어떻게 장애 복구를 처리할 것인가.

- 두 가지 안정성 속성을 만족해야 한다.
	- 신뢰성 있는 전달 : 어떤 메시지도 손실되지 않는다.
	- 전체 순서가 정해진 전달 : 메시지는 모든 노드에 같은 순서로 전달된다.

### 전체 순서 브로드캐스트 사용하기

- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다.
- 상태 기계 복제
	- 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다.

- 메시지가 전달되는 시점에 그 순서가 고정된다.

### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

- 전체 순서 브로드캐스트 구현이 있다면 이를 기반으로 한 선형성 저장소를 만들 수 있다.
- 전체 순서 브로드캐스트를 추가 전용 로그로 사용한 선형성 compare-and-set 연산
	- 메시지를 로그에 추가해서 점유하기 원하는 사용자명을 시험적으로 가리킨다.
	- 로그를 읽고, 추가한 메시지가 되돌아오기를 기다린다.
	- 원하는 사용자명을 점유하려고 하는 메시지가 있는지 확인한다.

- 로그 항목은 모든 노드에 같은 순서로 전달되므로 여러 개의 쓰기가 동시에 실행되면 모든 노드가 어떤 쓰기가 먼저 실행된 것인지 동의한다.
- 선형성 쓰기를 보장하지만 선형성 읽기는 보장하지 않는다.
- 읽기를 선형적으로 만드는 선택지
	- 로그를 통해 순차 읽기를 할 수 있다.
	- 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻을 수 있다면 그 위치를 질의하고 그 위치까지의 모든 항목이 전달되기를 기다린 후 읽기를 수행할 수 있다.
	- 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽을 수 있다.

### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

- 전체 순서 브로드캐스틑 통해 보내고 싶은 모든 메시지에 대해 선형성 정수로 increment-and-get 연산을 수행하고 레지스터에서 얻은 값을 일련번호로 메시지에 붙인다.
- 메시지를 모든 노드에 보낼 수 있고 수신자들은 일련번호 순서대로 메시지를 전달한다.
- 선형성 compare-and-set 레지스터와 전체 순서 브로드캐스트는 둘 다 합의와 동등하다고 증명할 수 있다.