# 9장 일관성과 합의

```
살아 있지만 틀린게 나은가, 올바르지만 죽은 게 나은가?
```

- 내결함성 : 시스템의 일부 구성 요소가 작동하지 않더라도 계속 작동할 수 있는 기능을 말한다.

- 모든 과정에서, 모든 개발자가 내결함성에 대해서 고민하는 것은 옳지 않다.
- 우리는 추상화를 해야한다.
- 합의 : 모든 노드가 어떠한 내용에 대해서 동의하게 만드는 것이다.
  - 합의 과정에서의 문제 : 리더 선출, 스플릿 브레인

## 일관성 보장
- 복제 데이터베이스는 대부분 최소한의 최종적 일관성을 제공한다.:
  - 최종적으로는 데이터가 수렴한다는 뜻이다.
  - 굉장히 약한 보장:
    - 더 강한 보장을 하기 위해서는 시간 제한과 같은 추가적인 제약사항이 생겨야한다.

## 선형성
- 선형성, 원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성
- 더티 읽기, 팬텀 읽기

### 선형성에 기대기
- 선형성의 필요성 제시

#### 잠금과 리더 선출
- 코디네이터 서비스(Zookeeper, etcd) 는 선형성 저장소 서비스가 기초적인 기반이 된다

#### 제약 조건과 유일성 보장
- 데이터베이스에서는 이러한 내용은 흔하다.
- 하지만 모든 서비스에서 반드시 이 내용이 엄격하게 보장되야할 필요는 없다.

#### 채널 간 타이밍 의존성
- 선형적의 최신성 보장이 없으면 일어나는 문제 예시:
  - 파일을 저장하는 저장소와 이를 전달/명령하는 메시지큐 간의 속도가 다르면 생기는 문제

### 선형성 시스템 구현하기
- 단일 리더 복제(선형적이 될 가능성이 있음), 합의 알고리즘(선형적), 다중 리더 복제(비선형적), 리더 없는 복제(아마도 비선형적)

### 선형성과 정족수
- 정족수 : 여러 사람의 합의로 운영되는 의ㅏ기관에서 의결을 하는데 필요한 최소한의 참석자 수이다.
- 단순히 정족수 조건을 만족한다고 했다고 해서 선형적이라는 것을 의미하는 것은 아니다.
- 즉, 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 가장 안전하다.

### 선형성의 비용
- 데이터 센터 간 네트워크가 끊기는 상황 가정:
  - 다중 리더 데이터베이스는 계속 정상 동작 할 수 있다.
    - 단지 리더간 네트워크가 끊기는 것처럼 보일 뿐이다.
    - 네트워크가 다시 연결되었을 때 리더간의 버퍼(큐)에 있는 내용을 서로간 합의를 보면 된다.(다중 리더는 평소에도 합의를 하고 있다.)
  - 단일 리더 데이터베이스에서는 리더가 없는 데이터 센터는 먹통이 된다.:
    - 이런 시스템은 사용할 수 없다.

### CAP 정리
- 애플리케이션에서 선형성을 요구하고 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면, 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리 할 수 없다.(가용성을 포기해야한다.)
- 애플리케이션에서 선형성을 요구하지 않는다면, 가용성을 선택할 수 있다.
- Consistency(일관성), Availability(가용성), Partition tolerance(분단 내성)

### 선형성과 네트워크 지연
- 최신 CPU는 코어간에서도 선형성이 보장되지 않는다.
- 대신 성능을 선택했다.
- 마찬가지로 네트워크게 결함이 없더라도, 분산 데이터베이스에서 선형성 보장을 위해서 느려지거나, 성능을 위해서 선형성 보장을 포기하던가 해야한다.

## 순서화 보장
- 순서화, 선형성, 합의 사이 깊은 연결관계를 지금까지 공부해왔다.

### 순서화와 인과성
- 네트워크 지연에 의해 쓰기 요청이 순서가 바뀔 수 있다.
- 인과성은 이벤트에 순서를 부과한다.
- 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적(casually consistent)이라고 한다.

#### 인과적 순서가 전체 순서는 아니다
- 질문-답 페어간에는 서로간 비교 불가하다.
- 선형성: 시스템 상의 모든 연산의 전체 순서를 정할 수 있다.
- 인과성: 부분 순서를 정의하며, 이에 따라 일부 연산들은 (설령 한쪽이 실제로 먼저 실행되었더라도) 동시적이라고 말한다.

- 예시 : 영화관 좌석 시스템

#### 선형성은 인과적 일관성보다 강하다.
- 선형성은 인과성을 포함한다.

### 인과적 의존성 담기
- 버전 벡터(version vector)를 일반화 할 수 있다.
- 인과적 순서를 결정하기 위해서 데이터베이스는 어플리케이션이 데이터의 어떤 버전을 읽었는지 알아야한다.

### 일련번호 순서화
- 시계(타임스탬프)를 사용해서 이벤트의 순서를 정할 수 있다.
- 반드시 시계일 필요는 없다. 논리적 시계(일련번호)를 얻어도 된다.

### 비인과적 일련번호 생성기
- 현실에서 (단일 상황에서 일반적으로) 사용되는 다양한 방법:
  - 각 노드마다 자신만의 일련번호 집합을 가지는 것:
    - 각 노드당 성능이 달라서 한쪽이 뒤쳐지는 경우가 발생한다.
  - 각 연산에 물리적 시계를 사용한 타임스탬프를 사용한다.:
    - 물리적 시계 문제를 극복해야한다.
  - 일련번호 블록을 미리 할당해놓는다.:
    - 블록 내부간은 인과성이 있지만, 블록간은 인과성을 알 수 없다.

### 램포트 타임스탬프
- (카운터, 노드 ID) 쌍을 사용하는 것이다.
- 클라이언트는 각 노드의 카운터 값중 최댓값을 추적하여 노드간의 인과성을 추적한다.

### 타임스탬프 순서화로는 충분하지 않다.
- 당장 성공, 실패를 확인하려고 할때는 지금 즉시, 인과성을 알아내야한다. (예시: 계정 생성)

## 전체 순서 브로드캐스트
- 전체 순서 브로드캐스트(total order broadcast), 원자적 브로드캐스트(atomic broadcast) : 처리량이 단일 리더가 처리 할 수 있는 수준을 넘어설 때 어떻게 확장할 것인가, 리더에 장애가 발생하였을때 어떻게 장애 복구를 처리할 것인가?
- 비공식적으로는 아래 두가지 안전성 속성을 항상 만족해야지 보장할 수 있다고 알려져 있다.:
  - 신뢰성 있는 전달 : 어떤 메시지도 손실되지 않는다. 메시지가 한 노드에 전달되면 모든 노드에도 전달된다.
  - 전체 순서가 정해진 전달 : 메시지는 모든 노드에 같은 순서로 전달 된다.

### 전체 순서 브로드캐스트 사용하기
- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다.
- 상태 기계 복제(state machine replication) : 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다.

- 키포인트:
  - 메시지가 전달되는 시점에 그 순서가 고정된다.
  - 일종의 로그를 만드는 방법 중 하나라고 해석할 수 있다.

### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기
- 전체 순서 브로드캐스트는 비동기식이다. -> 언제 전달될지는 보장하지 않는다.
- compare-and-set 과 같은 연산을 전체 순서 브로드캐스트를 활용해 구현 가능하기 때문에 다양한 곳에 사용될 수 있다.
- 이는 선형성 쓰기를 보장해준다. (순차적 일관성, 타임라인 일관성으로 불리기도 한다.)

### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기
- 반대로 compare-and-set, increment-and-get 연산이 지원되면 선형 레지스터를 구현 가능하고, 이는 결과적으로 전체 순서 브로드캐스트를 구현할 수 있어진다.

