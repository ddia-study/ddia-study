# 9장 일관성과 합의

- 분산시스템에서의 오류
    - 서비스가 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것
    - 결함을 견뎌내게 서비스를 설계
- 내결함성을 지닌 시스템을 구축하는 방법 → 보장을 해주는 범용 추상화를 찾아 구현 + 애플리케이션에서 보장에 의존
- 분산 시스템에 가장 중요한 추상화 : 합의

+) 스플릿 브레인 : 두 노드가 자신이 리더라고 생각하는 상황

---

- 일관성 보장
    - 복제 데이터베이스는 대부분 최소한 **최종적 일관성** 제공
    - 최종적 일관성은 시간이 지나면 결국 일치됨 aka “수렴” ← 약한 보장(언제인지를 모름)
    - 약한 보장만으론 제한을 계속 알아야하고 가정이 많으면 안됨
    1. 선형성 : 가장 강한 일관성 모델 중 하나
    2. 분산 시스템에서 이벤트 순서화 문제, 인과성과 전체 순서화
    3. 분산 트랜잭션을 원자적으로 커밋하는 방법, 합의

- 선형성
    - 두 개의 복제본에 질문을 날리는 것이 아니라 하나가 있다는 생각에서 시작
    - 선형성 = 최신성 보장
    - 하나의 데이터베이스가 있다고 생각하여 최선성을 보장함(질의가 오래된 결과를 반환하지 않음)

- 시스템에 선형성을 부여하는 것?
    - 데이버 복사본이 하나뿐인 것처럼 보이게 만드는 것
    - 읽기가 새로운 값을 반환한 적이 있는 후에는 모든 후속 읽기도 새로운 값 반환
    - 연산이 실제적으로 수행됐다는 선들이 항상 시간순으로 진행돼야함
    
- 선형성 vs 직렬성
    - 직렬성 : 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성
    - 선형성 : 레지스터에 실행되는 읽기와 쓰기에 대한 최신성 보장
    
- 선형성에 기대기
    - 잠금과 리더 선출
        - 리더가 진짜로 하나만 존재하도록 보장
        - 잠금을 소유하는지에 대한 확인
    - 제약 조건과 유일성 보장
        - 제약 조건 같은 유일하게 식별
        - 잠금의 상황과 유사(+ CAS 방식)

- 선형성 시스템 구현하기
    - 선형성 : “데이터 복사본이 하나만 있는 것처럼 동작하고 데이터에 실행되는 모든 연산은 원자적”
    - 정말로 데이터를 하나만 갖기에는 결함을 견딜 수가 없다. → 복제를 사용하는 방법
    - 단일 리더 복제, 합의 알고리즘, 다중 리더 복제, 리더 없는 복제
    
- 선형성과 정족수
    - 다이나모 스타일 모델에서 업격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보임
    - BUT, 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있음
    - 성능이 떨어지는 비용을 지불하고 다이나모 스타일 정족수를 선형적으로 만드는게 가능

- CAP 정리
    - 선형성이 필요 없는 애플리케이션은 네트워크 문제에 더 강인하다. → 에릭 부루어의 CAP 정리
    - 초기에 DB에서 트레이드 오프에 대한 논의를 시작하려는 목적으로 정확한 정의 없이 제안됐음.
    - CAP : 일관성(Consistency), 가용성(Availiablity), 분단 내성(Partition tolerance) 이라는 세 개 중 두개를 고르라.
    - CAP가 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미
    
- 선형성과 네트워크 지연
    - CPU 코어는 저마다 메모리 캐시와 저장 버퍼를 갖음
    - 메모리 접근은 기본적으로 캐시로 먼저 가고 변경은 메인 메모리에 비동기로 기록됨
    - 이런 트레이드 오프를 만드는 이유는 “성능” 때문에

---

- 순서화 보장
    - 순서화와 인과성
        - 순서화가 인과성을 보존하는 데 도움을 줌(동시 쓰기 감지, 스냅숏 격리, 일관된 순서로 읽기)
        - 인과성은 이벤트에 순서를 부과함, 결과가 나타나기 전에 원인이 발생.
        - 시스템이 인과성에 의해 부과된 순서를 지키면 시스템은 인과적으로 일관적(consistence)라고 함
        - 데이터 베이스에서 읽어서 데이터의 조각을 봤다면 그보다 인과적으로 먼저 발생한 어떤 데이터도 볼 수 있어야 함
    - 인과적 순서는 전체 순서는 아니다.
        - 전체 순서 : 어떤 두 요소를 비교할 수 있게 어떤 것이 크고 어떤 것이 작은지 말할 수 있음
        - 어떤 수들은 비교불가 따라서 수학적
        - 집합은 “부분적으로 순서가 정해짐”
        - 선형성
            - 연산의 전체 순서를 정할 수 있음
        - 인과성
            - 전체 순서가 아닌 부분 순서
            - 인과적인 관계가 있으면 순서가 있지만
            - 동시에 실행되면 비교할 수 없음
    - 선형성은 인과적 일관성보다 강하다.
        - 선형성은 인과성을 내포함 → 선형적이라면 인과성도 유지
        - 선형성은 인과성을 보존하는 유일한 방법이 아님
        - 인과적 일관성은 네트워크 지연 때문에 느려지지 않고 네트워크 장애가 발생해도 가용한 일관성 모델 중 가장 강함
    - 인과적 의존성 담기
        - 인과성 유지를 위해 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 함
        - 전체 데이터베이스에 걸친 인과적 의존성을 추적함으로써 의존성 결정
    - 일련번호 순서화
        - 일련번호나 타임스템프를 써서 이벤트의 순서를 정할 수 있음
        - 인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있음
    - 램포트 타임스탬프
        - 각 노드는 고유 식별자를 갖고 각 노드는 처리한 연산 개수를 카운터로 유지함
        - 두 노드의 카운터 값이 같을 경우 노드 ID를 포함시켜 타임스탬프는 유일하게 됨
            - 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함.
            - 노드가 자신의 카운터 값보다 큰 카운터를 가진 요청이나 응답을 받으면 바로 자신의 카운터를 그 최댓값으로 증가
        - 하지만 여전히 충분하지는 않음, 당장 결정해야하는 등의 경우 다른 노드가 연산에 어떤 타임스탬프를 사용할지 모름
    - 전체 순서 브로드캐스트
        - 노드 사이에 메시지를 교환하는 프로토콜
        - 2가지 안정성을 만족해야함 : 신뢰성 있는 전달, 전체 순서가 정해진 전달
        - 데이터 베이스 복제에 필요한 것으로 모든 메시지가 데이터베이스 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들이 일관성 있는 상태 유지 ← 상태 기계 복제
    - 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기
        - 선형성 시스템에는 연산의 전체 순서가 있음, but 브로드캐스트와 완전히 같지는 않음(유사)
        - 전체 순서 브로드캐스트 : 비동기식, 선형성 : 최신성 보장
        - 전체 순서 브로드캐스트 구현이 있으면 이를 기반으로 선형성 저장소 만들기 가능
    - 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기
        - 선형성 저장소가 있을 때 이를 기반으로 전체 순서 브로드캐스트를 구현
        - 원자적 increment-and-get 연산 지원하는 레지스터 있다고 가정
        1. 전체 순서 브로드캐스트를 통해 보내고 싶은 모든 메시지에 대해 선형성 정수로 increment-and-get 연산을 수행
        2. 레지스터에서 얻은 값을 일련번호로 메세지에 붙임
        3. 메시지를 모든 노드에 보낼 수 있고, 수신자들이 일련번호 순서대로 메시지를 전달